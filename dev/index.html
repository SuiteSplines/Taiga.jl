<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Taiga.jl</title><meta name="title" content="Home · Taiga.jl"/><meta property="og:title" content="Home · Taiga.jl"/><meta property="twitter:title" content="Home · Taiga.jl"/><meta name="description" content="Documentation for Taiga.jl."/><meta property="og:description" content="Documentation for Taiga.jl."/><meta property="twitter:description" content="Documentation for Taiga.jl."/><meta property="og:url" content="https://SuiteSplines.github.io/Taiga.jl/"/><meta property="twitter:url" content="https://SuiteSplines.github.io/Taiga.jl/"/><link rel="canonical" href="https://SuiteSplines.github.io/Taiga.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img class="docs-light-only" src="assets/logo.svg" alt="Taiga.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.svg" alt="Taiga.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>Taiga.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Postprocessing"><span>Postprocessing</span></a></li><li><a class="tocitem" href="#Aggregation-of-Kronecker-products"><span>Aggregation of Kronecker products</span></a></li><li><a class="tocitem" href="#KroneckerFactory"><span><code>KroneckerFactory</code></span></a></li><li><a class="tocitem" href="#Linear-solvers"><span>Linear solvers</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="poisson/">Poisson equation</a></li><li><a class="tocitem" href="potentialflow/">Potential flow</a></li><li><a class="tocitem" href="immersed_potentialflow/">Immersed potential flow</a></li><li><a class="tocitem" href="linearelasticity/">Linear elasticity</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SuiteSplines/Taiga.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SuiteSplines/Taiga.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Taiga.jl"><a class="docs-heading-anchor" href="#Taiga.jl">Taiga.jl</a><a id="Taiga.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Taiga.jl" title="Permalink"></a></h1><p>Tensor-product applications in isogeometric analysis.</p><div class="admonition is-info" id="Note-655faab25f40e743"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-655faab25f40e743" title="Permalink"></a></header><div class="admonition-body"><p>Examples listed on this page use following packages</p><pre><code class="language-julia hljs">using Taiga
using LinearAlgebra
using SortedSequences, CartesianProducts, KroneckerProducts, NURBS, SpecialSpaces, AbstractMappings, UnivariateSplines</code></pre></div></div><h2 id="Postprocessing"><a class="docs-heading-anchor" href="#Postprocessing">Postprocessing</a><a id="Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocessing" title="Permalink"></a></h2><p>Some basic postprocessing methods are provided as <code>Plots</code> recipes in most packages in the <code>Feather</code> ecosystem. <code>Taiga.jl</code> implements Bézier extraction and can save mappings, fields and control nets to a <code>VTK</code> file, e.g</p><pre><code class="language-julia hljs">mapping = hole_in_square_plate()
mapping = refine(mapping, method=hRefinement(3))
space = ScalarSplineSpace(mapping.space)

euclidean_distance = Field((x,y) -&gt; sqrt(x^2 + y^2))
d = Field(space)
project!(d, onto=euclidean_distance ∘ mapping; method=QuasiInterpolation)

vtk_save_bezier(&quot;geometry_and_field&quot;, mapping; fields = Dict(&quot;d&quot; =&gt; d))
vtk_save_control_net(&quot;control_net&quot;, mapping)</code></pre><p><img src="assets/square_plate_with_hole_bezier_example.png" alt="Bezier extraction on square plate with a hole"/></p><p>More detailed examples are provided in the <code>examples</code> directory.</p><h2 id="Aggregation-of-Kronecker-products"><a class="docs-heading-anchor" href="#Aggregation-of-Kronecker-products">Aggregation of Kronecker products</a><a id="Aggregation-of-Kronecker-products-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregation-of-Kronecker-products" title="Permalink"></a></h2><p>More often then not Kronecker product approximations will be composed of a sum of Kronecker products. In most cases these sums will not have the classical <a href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker sum</a> structure. Nonetheless, it is still possible to evaluate matrix-vector products with these operators with complexity <span>$\mathcal O(M\cdot N^{3/2})$</span> and  <span>$\mathcal O(M\cdot N^{4/3})$</span> in 2 and 3 dimensions, where <span>$M$</span> is the number of Kronecker products in the collection.</p><p><a href="#Taiga.KroneckerProductAggregate"><code>KroneckerProductAggregate</code></a> is a collection of Kronecker product matrices of conforming size that acts as a linear map and supports reduction over the collection, e.g.</p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(7, 3) ⊗ rand(5, 3) ⊗ rand(3, 5);

julia&gt; B = rand(7, 3) ⊗ rand(5, 3) ⊗ rand(3, 5);

julia&gt; C = A + B;

julia&gt; K = KroneckerProductAggregate(A, B);

julia&gt; v = rand(size(C, 2));

julia&gt; b = K * v;

julia&gt; b ≈ C * v
true

julia&gt; mul!(b, K, v); # in-place evaluation

julia&gt; b ≈ C * v
true</code></pre><p>A <a href="#Taiga.KroneckerProductAggregate"><code>KroneckerProductAggregate</code></a> supports <code>LinearAlgebra.mul!</code>, <code>LinearAlgebra.adjoint</code>, <code>Base.isempty</code>, <code>Base.push!</code> and most other  methods that abstract matrices implement.</p><h2 id="KroneckerFactory"><a class="docs-heading-anchor" href="#KroneckerFactory"><code>KroneckerFactory</code></a><a id="KroneckerFactory-1"></a><a class="docs-heading-anchor-permalink" href="#KroneckerFactory" title="Permalink"></a></h2><p>Let us consider that we need to assemble the bilinear form associated with the operator <code>L(u) = ∇ ⋅ (C∇u)</code> where <code>C = [6.0 0.1875; 0.125 12.0]</code> is a conductivity matrix. Clearly, even on Cartesian grids an exact <a href="#Taiga.FastDiagonalization"><code>FastDiagonalization</code></a> of the resulting matrix is not possible due to non-zero off-diagonal entries in <code>C</code>. Furthermore, if <code>C</code> is a function of the spatial coordinates, the resulting stiffness matrix does not have a Kronecker product structure at all and the material pullback needs to be approximated using some separable approximation.</p><p><a href="#KroneckerFactory"><code>KroneckerFactory</code></a> can be used to obtain approximations of a bilinear form given a separable approximation of the data, i.e. weighted spline approximation of the pullback operator on mapped geometries or Wachspress approximation at quadrature points.</p><p>The syntax is close to that of <code>IgaFormation.Sumfactory</code>.</p><pre><code class="language-julia hljs"># domain
Ω = Interval(0.0, 1.0) ⨱ Interval(0.0, 1.0)

# partition
Δ = Partition(Ω, (3,5))

# space
p = (2,3)
S = ScalarSplineSpace(p, Δ)

# mock data
Dim = length(S)
nqpts = map((p,n) -&gt; (p+1)*n + 2, p, num_elements.(S))
f = [ map(rand, nqpts) for k ∈ 1:Dim, l ∈ 1:Dim]

# derivative indicators
∇u = k -&gt; ι(k, dim=Dim)
∇v = k -&gt; ι(k, dim=Dim)

# assemble stiffness
∫ = KroneckerFactory(S, S)
for β in 1:Dim
    for α in 1:Dim
        ∫(∇u(α), ∇v(β); data=f[α, β])
    end
end

# aggregated Kronecker products
K = ∫.data</code></pre><p>In the above, <code>f[α, β]</code> is a <code>Tuple</code> of either univariate weighting splines in each parametric direction or plain vectors with weighting coefficients. This data is used to weight the test functions. </p><p>Similarly to <code>Sumfactory</code>, the data collection can be reset</p><pre><code class="language-julia hljs">∫(∇u(α), ∇v(β); data=f[α, β], reset=true)</code></pre><p>or simply</p><pre><code class="language-julia hljs">reset!(∫)</code></pre><h2 id="Linear-solvers"><a class="docs-heading-anchor" href="#Linear-solvers">Linear solvers</a><a id="Linear-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solvers" title="Permalink"></a></h2><p>Taiga provides minimal reference implementations of linear solvers:</p><ul><li><a href="#Taiga.TaigaCG"><code>TaigaCG</code></a> Conjugate Gradient method</li><li><a href="#Taiga.TaigaPCG"><code>TaigaPCG</code></a> preconditioned Conjugate Gradient method</li><li><a href="#Taiga.TaigaIPCG"><code>TaigaIPCG</code></a> inexactly preconditioned Conjugate Gradient method</li></ul><p>These implementations are reasonably fast. The solution times are at least as good as <code>Krylov.jl</code>, whereby due to the minimal implementation there are less memory allocations. Furthermore, some solvers like <a href="#Taiga.TaigaIPCG"><code>TaigaIPCG</code></a> are nowhere to be found and are essential to Taiga&#39;s conceptual framework.</p><pre><code class="language-julia-repl hljs">julia&gt; solver = TaigaPCG(L, P; atol=10e-8, rtol=10e-8, itmax=100)
Linear solver of type TaigaPCG (atol=1.0e-7, rtol=1.0e-7, itmax=100)

julia&gt; x, stats = linsolve!(solver, b);

julia&gt; stats
Linear solver statistics for TaigaPCG:
┌──────────────────┬───────────────────────────────┐
│ Metric           │ Value                         │
├──────────────────┼───────────────────────────────┤
│ converged        │ true                          │
│ niter            │ 47                            │
│ residual_norm    │ 9.25797e-8                    │
│ residual_norm_x₀ │ 0.0732086                     │
│ status           │ coverged: atol ✔, rtol ✘      │
└──────────────────┴───────────────────────────────┘</code></pre><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Taiga.BezierExtractionContext"><a class="docstring-binding" href="#Taiga.BezierExtractionContext"><code>Taiga.BezierExtractionContext</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BezierExtractionContext{Dim, T}</code></pre><p>Bezier extraction context.</p><p><strong>Fields:</strong></p><ul><li><code>splinespace::TensorProduct{Dim, SplineSpace{T}}</code>: spline space</li><li><code>partition::CartesianProduct{Dim}</code>: partition</li><li><code>C::Array{KroneckerProduct, Dim}</code>: Bezier extraction operators</li><li><code>bezier_basis_dimension::NTuple{Dim}</code>: Bezier basis dimension</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L33-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.BezierExtractionContext-Union{Tuple{UnivariateSplines.SplineSpace{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Taiga.BezierExtractionContext-Union{Tuple{UnivariateSplines.SplineSpace{T}}, Tuple{T}} where T"><code>Taiga.BezierExtractionContext</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BezierExtractionContext(S::SplineSpace{T})</code></pre><p>Construct <a href="#Taiga.BezierExtractionContext"><code>BezierExtractionContext</code></a> from a univariate spline space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L68-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.CanonicalPolyadic"><a class="docstring-binding" href="#Taiga.CanonicalPolyadic"><code>Taiga.CanonicalPolyadic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CanonicalPolyadic &lt;: DataApproximationMethod</code></pre><p>Method to approximate patch data as separable functions using Canonical polyadic decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/approximation.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.Constrained"><a class="docstring-binding" href="#Taiga.Constrained"><code>Taiga.Constrained</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Constrained{x}</code></pre><p>Can be used as a constrained/unconstrained flag. Similar to <code>Val</code> but takes only booleans as <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/models.jl#L78-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.DataApproximationMethod"><a class="docstring-binding" href="#Taiga.DataApproximationMethod"><code>Taiga.DataApproximationMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type DataApproximationMethod</code></pre><p>Concrete data approximatino methods derive from this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/approximation.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.FastDiagonalization"><a class="docstring-binding" href="#Taiga.FastDiagonalization"><code>Taiga.FastDiagonalization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FastDiagonalization{Dim,T,K&lt;:KroneckerProduct{T}}</code></pre><p>Fast diagonalization preconditioner.</p><p><strong>Fields:</strong></p><ul><li><code>Λ⁻¹::Diagonal{T, Vector{T}}</code>: diagonal matrix of reciprocal of positive eigenvalues</li><li><code>U::K</code>: Kronecker product eigenvectors</li><li><code>size::NTuple{2, Int}</code>: operator size</li><li><code>cache::Vector{T}</code>: intermediate product cache</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L27-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.HyperPowerPreconditioner"><a class="docstring-binding" href="#Taiga.HyperPowerPreconditioner"><code>Taiga.HyperPowerPreconditioner</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HyperPowerPreconditioner{Dim, T, A &lt;: LinearOperatorApproximation{Dim, T}, B &lt;: Preconditioner{Dim, T}}</code></pre><p>Preconditioner based on the <a href="http://benisrael.net/COHEN-BI-ITER-GI.pdf">Ben-Israel-Cohen iteration</a>.</p><pre><code class="nohighlight hljs">Pₖ₊₁⁻¹ = 2 Pₖ⁻¹ - Pₖ⁻¹ A Pₖ⁻¹     (Pₖ⁻¹ → A⁻¹   for   k → ∞)</code></pre><p>Requires a linear operator <code>A</code> and an initial preconditioner <code>P</code>. Computes one update of the Ben-Israel-Cohen iteration. Convergence to <code>A⁻¹</code> and positive definiteness are guaranteed as long as <code>σ(P⁻¹A) ⊂ (0,2)</code>.</p><p>For recursive application, i.e. <code>n</code> iterations, use the convenience constructor</p><pre><code class="nohighlight hljs">HyperPowerPreconditioner(L::A, P::B, n::Int) where {Dim,T,A&lt;:LinearOperatorApproximation{Dim,T},B&lt;:Preconditioner{Dim,T}}</code></pre><p>where <code>P</code> is the initial preconditioner and <code>n</code> is the number of updates.</p><p><strong>Fields:</strong></p><ul><li><code>A::A</code>: linear operator of which the inverse is approximated</li><li><code>P::B</code>: initial preconditioner</li><li><code>v₁::Vector{T}</code>: vector cache</li><li><code>v₂::Vector{T}</code>: vector cache</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L402-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.InnerCG"><a class="docstring-binding" href="#Taiga.InnerCG"><code>Taiga.InnerCG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InnerCG{Dim, T, L &lt;: LinearOperatorApproximation} &lt;: Preconditioner{Dim,T}</code></pre><p>Preconditioner using inner CG solver. In applications the linear operator approximation <code>A</code> can be cheaply applied to a vector. The parameter <code>η ∈ [0,1)</code> controls the tolerance of the inner solve. Decreasing <code>η</code> increases the number of inner iterations.</p><p>The history can be reset using <a href="#Taiga.reset_inner_solver_history!-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><code>reset_inner_solver_history!</code></a>.</p><p><strong>Fields:</strong></p><ul><li><code>A::L</code>: approximation of a linear operator to be preconditioned</li><li><code>p::Vector{T}</code>: cache vector</li><li><code>Ap::Vector{T}</code>: cache vector</li><li><code>r::Vector{T}</code>: cache vector</li><li><code>η::T</code>: factor for convergence criterion (<code>η ∈ [0,1)</code>)</li><li><code>η̂::T</code>: factor for convergence criterion respective <code>cond(A)</code></li><li><code>itmax::Int</code>: maximum number of inner iterations</li><li><code>convergence::Vector{Bool}</code>: vector with history of convergence</li><li><code>residuals::Vector{T}</code>: vector with history of residuals</li><li><code>niters::Vector{Int}</code>: vector with history of number of iterations</li><li><code>history::Bool</code>: boolean flag for history keeping</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L71-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.InnerCG-Union{Tuple{L}, Tuple{T}, Tuple{Dim}} where {Dim, T, L&lt;:LinearOperatorApproximation{Dim, T}}"><a class="docstring-binding" href="#Taiga.InnerCG-Union{Tuple{L}, Tuple{T}, Tuple{Dim}} where {Dim, T, L&lt;:LinearOperatorApproximation{Dim, T}}"><code>Taiga.InnerCG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InnerCG(A::L; history=false, itmax::Int=200, η::T=10e-5, eigtol::T=10e-2) where {Dim,T,L&lt;:LinearOperatorApproximation{Dim,T}}</code></pre><p>Construct <a href="#Taiga.InnerCG"><code>InnerCG</code></a> preconditioner. The positive definiteness is checked by <a href="#Taiga.extreme_eigenvalues-Union{Tuple{L}, Tuple{T}} where {T, L&lt;:LinearMaps.LinearMap}"><code>extreme_eigenvalues</code></a>. The <code>eigtol</code> keyword controls the tolerance for the extreme eigenvalues computation.</p><p><strong>Arguments:</strong></p><ul><li><code>A::L</code>: approximatino of a linear operator to be preconditioned</li><li><code>history::Bool</code>: boolean flag for history keeping</li><li><code>η::T</code>: factor for convergence criterion (<code>η ∈ [0,1)</code>)</li><li><code>skip_checks::Bool</code>: boolean flag for skipping posdef checks (default: <code>false</code>)</li><li><code>itmax::Int</code>: maximum number of inner iterations</li><li><code>eigtol::T</code>: tolerance for <code>extreme_eigenvalues</code>](@ref) computation</li><li><code>eigrestarts::Int</code>: number of restarts for <code>extreme_eigenvalues</code>](@ref) computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L106-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.InnerPCG"><a class="docstring-binding" href="#Taiga.InnerPCG"><code>Taiga.InnerPCG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InnerPCG{Dim, T, L &lt;: LinearOperatorApproximation{Dim, T}, P &lt;: Preconditioner{Dim, T}}</code></pre><p>Preconditioner using inner PCG solver. In applications the linear operator approximation <code>A</code> can be cheaply applied to a vector. The preconditioner <code>P</code> preconditions the inner solve. The parameter <code>η ∈ [0,1)</code> controls the tolerance of the inner solve. Decreasing <code>η</code> increases the number of inner iterations.</p><p>The history can be reset using <a href="#Taiga.reset_inner_solver_history!-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><code>reset_inner_solver_history!</code></a>.</p><p><strong>Fields:</strong></p><ul><li><code>A::L</code>: approximation of a linear operator to be preconditioned</li><li><code>M::P</code>: preconditioner for the inner solve</li><li><code>p::Vector{T}</code>: cache vector</li><li><code>Ap::Vector{T}</code>: cache vector</li><li><code>r::Vector{T}</code>: cache vector</li><li><code>z::Vector{T}</code>: cache vector</li><li><code>η::T</code>: factor for convergence criterion (<code>η ∈ [0,1)</code>)</li><li><code>η̂::T</code>: factor for convergence criterion respective <code>cond(A)</code></li><li><code>itmax::Int</code>: maximum number of inner iterations</li><li><code>convergence::Vector{Bool}</code>: vector with history of convergence</li><li><code>residuals::Vector{T}</code>: vector with history of residuals</li><li><code>niters::Vector{Int}</code>: vector with history of number of iterations</li><li><code>history::Bool</code>: boolean flag for history keeping</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L203-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.InnerPCG-Union{Tuple{P}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{L, P}} where {Dim, T, L&lt;:LinearOperatorApproximation{Dim, T}, P&lt;:Preconditioner{Dim, T}}"><a class="docstring-binding" href="#Taiga.InnerPCG-Union{Tuple{P}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{L, P}} where {Dim, T, L&lt;:LinearOperatorApproximation{Dim, T}, P&lt;:Preconditioner{Dim, T}}"><code>Taiga.InnerPCG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InnerPCG(A::L, P; history=false, itmax::Int=200, η::T=10e-5, eigtol::T=10e-2) where {Dim,T,L&lt;:LinearOperatorApproximation{Dim,T}}</code></pre><p>Construct <a href="#Taiga.InnerCG"><code>InnerCG</code></a> preconditioner. The positive definiteness is checked by <a href="#Taiga.extreme_eigenvalues-Union{Tuple{L}, Tuple{T}} where {T, L&lt;:LinearMaps.LinearMap}"><code>extreme_eigenvalues</code></a>. The <code>eigtol</code> keyword controls the tolerance for the extreme eigenvalues computation.</p><p><strong>Arguments:</strong></p><ul><li><code>A::L</code>: approximatino of a linear operator to be preconditioned</li><li><code>history::Bool</code>: boolean flag for history keeping</li><li><code>η::T</code>: factor for convergence criterion (<code>η ∈ [0,1)</code>)</li><li><code>skip_checks::Bool</code>: boolean flag for skipping posdef checks (default: <code>false</code>)</li><li><code>itmax::Int</code>: maximum number of inner iterations</li><li><code>eigtol::T</code>: tolerance for <code>extreme_eigenvalues</code>](@ref) computation</li><li><code>eigrestarts::Int</code>: number of restarts for <code>extreme_eigenvalues</code>](@ref) computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L243-L258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.KroneckerFactory"><a class="docstring-binding" href="#Taiga.KroneckerFactory"><code>Taiga.KroneckerFactory</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KroneckerFactory{Dim, T, S &lt;: SplineSpace{T}, K &lt;: KroneckerProductAggregate{T}}</code></pre><p>A factory that assembles Kronecker product system matrices. Acts as a functor accepting optional weighting for test functions and collects Kronecker product matrix contributions in a <a href="#Taiga.KroneckerProductAggregate"><code>KroneckerProductAggregate</code></a>.</p><p><strong>Fields:</strong></p><ul><li><code>trialspace::TensorProduct{Dim, S}</code>: trial functions space</li><li><code>testspace::TensorProduct{Dim, S}</code>: test functions space</li><li><code>data::K</code>: Kronecker product contributions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckerfactory.jl#L3-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.KroneckerFactory-Union{Tuple{S}, Tuple{T}, Tuple{Dim}, Tuple{CartesianProducts.TensorProduct{Dim, S}, CartesianProducts.TensorProduct{Dim, S}}} where {Dim, T, S&lt;:UnivariateSplines.SplineSpace{T}}"><a class="docstring-binding" href="#Taiga.KroneckerFactory-Union{Tuple{S}, Tuple{T}, Tuple{Dim}, Tuple{CartesianProducts.TensorProduct{Dim, S}, CartesianProducts.TensorProduct{Dim, S}}} where {Dim, T, S&lt;:UnivariateSplines.SplineSpace{T}}"><code>Taiga.KroneckerFactory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KroneckerFactory(trialspace::TensorProduct{Dim, S}, testspace::TensorProduct{Dim, S}) where {Dim,T,S&lt;:SplineSpace{T}}</code></pre><p>Constructs <a href="#KroneckerFactory"><code>KroneckerFactory</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>trialspace</code>: trial functions space</li><li><code>testspace</code>: test functions space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckerfactory.jl#L21-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.KroneckerFactory-Union{Tuple{T}, Tuple{N}, Tuple{Dim}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where {Dim, N, T&lt;:Real}"><a class="docstring-binding" href="#Taiga.KroneckerFactory-Union{Tuple{T}, Tuple{N}, Tuple{Dim}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where {Dim, N, T&lt;:Real}"><code>Taiga.KroneckerFactory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">f::KroneckerFactory{Dim}(v::NTuple{N, Int}, w::NTuple{N, Int}; data = nothing, reset::Bool=false)</code></pre><p>Assembles Kronecker product system matrices with test functions weighted by <code>data</code> (optional). The Kronecker product contributions are collected in the <code>f.data</code> which is a  <a href="#Taiga.KroneckerProductAggregate"><code>KroneckerProductAggregate</code></a>.</p><p>For applicable data see <a href="#Taiga.weighted_system_matrix"><code>weighted_system_matrix</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>v</code>: tuple indicating trial function derivatives, see <a href="#Taiga.ι-Tuple{Int64, Int64}"><code>ι</code></a></li><li><code>w</code>: tuple indicating test function derivatives, see <a href="#Taiga.ι-Tuple{Int64, Int64}"><code>ι</code></a></li><li><code>data</code>: optional weighting of test functions</li><li><code>reset</code>: optional flag to reset the collection <code>f.data</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckerfactory.jl#L37-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.KroneckerProductAggregate"><a class="docstring-binding" href="#Taiga.KroneckerProductAggregate"><code>Taiga.KroneckerProductAggregate</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KroneckerProductAggregate{T,S&lt;:KroneckerProduct{T}} &lt;: LinearMap{T}</code></pre><p>A collection of Kronecker product matrices that acts as a  linear operator represented by a sum over that collection.</p><p><strong>Fields:</strong></p><ul><li><code>K::Vector{KroneckerProduct}</code>: collection of Kronecker products</li><li><code>size::Tuple{Int,Int}</code>: size of the operator</li><li><code>cache::Vector{T}</code>: matrix-vector product cache</li><li><code>isposdef::Bool</code>: operator is positive definite flag</li><li><code>ishermitian::Bool</code>: operator is hermitian flag</li><li><code>issymmetric::Bool</code>: operator is symmetric flag</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckeraggregate.jl#L3-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.KroneckerProductAggregate-Union{Tuple{Int64, Int64}, Tuple{T}} where T"><a class="docstring-binding" href="#Taiga.KroneckerProductAggregate-Union{Tuple{Int64, Int64}, Tuple{T}} where T"><code>Taiga.KroneckerProductAggregate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KroneckerProductAggregate{T}(m::Int, n::Int; isposdef::Bool=false, ishermitian::Bool=false, issymmetric::Bool=false) where {T}</code></pre><p>Constructs an empty <a href="#Taiga.KroneckerProductAggregate"><code>KroneckerProductAggregate</code></a> of size <code>m × n</code> and properties defined by boolean keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckeraggregate.jl#L25-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.KroneckerProductAggregate-Union{Tuple{Vararg{S, N}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S&lt;:(KroneckerProducts.KroneckerProduct{T})}"><a class="docstring-binding" href="#Taiga.KroneckerProductAggregate-Union{Tuple{Vararg{S, N}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S&lt;:(KroneckerProducts.KroneckerProduct{T})}"><code>Taiga.KroneckerProductAggregate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KroneckerProductAggregate{T}(m::Int, n::Int; isposdef::Bool=false, ishermitian::Bool=false, issymmetric::Bool=false) where {T}</code></pre><p>Constructs a <a href="#Taiga.KroneckerProductAggregate"><code>KroneckerProductAggregate</code></a> based on an arbitrary number of Kronecker products with equal size. Aggregate properties are defined by boolean keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckeraggregate.jl#L37-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.LinearOperator"><a class="docstring-binding" href="#Taiga.LinearOperator"><code>Taiga.LinearOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type LinearOperator{Dim,T}</code></pre><p>Concrete linear operators derive from this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/models.jl#L15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.LinearOperatorApproximation"><a class="docstring-binding" href="#Taiga.LinearOperatorApproximation"><code>Taiga.LinearOperatorApproximation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type LinearOperatorApproximation{Dim,T}</code></pre><p>Concrete linear operator approximations derive from this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/models.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.LinearSolver"><a class="docstring-binding" href="#Taiga.LinearSolver"><code>Taiga.LinearSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type LinearSolver{T} end</code></pre><p>Concrete linear solvers derive from this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L7-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.LinearSolverStatistics"><a class="docstring-binding" href="#Taiga.LinearSolverStatistics"><code>Taiga.LinearSolverStatistics</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearSolverStatistics{S &lt;: LinearSolver}</code></pre><p>A container for solver statistics. Contains a dictionary <code>data</code>. Keys in <code>data</code> are used to mimic actual fields in this container, see <a href="#Base.propertynames-Tuple{LinearSolverStatistics}"><code>Base.propertynames</code></a>. Each property can be accessed using <a href="#Base.setproperty!-Tuple{LinearSolverStatistics, Symbol, Any}"><code>Base.setproperty!</code></a> and <a href="#Base.getproperty-Tuple{LinearSolverStatistics, Symbol}"><code>Base.getproperty</code></a>, or <code>stats.propname</code>. The dictonary itself is not accessable via <code>A.data</code>!</p><p><strong>Fields:</strong></p><ul><li><code>data::Dict{Symbol, Any}</code>: dictionary containing statistics</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L31-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.LinearSolverStatistics-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:LinearSolver"><a class="docstring-binding" href="#Taiga.LinearSolverStatistics-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:LinearSolver"><code>Taiga.LinearSolverStatistics</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearSolverStatistics(::Type{S}) where {S&lt;:LinearSolver}</code></pre><p>Default <a href="#Taiga.LinearSolverStatistics"><code>LinearSolverStatistics</code></a> constructor for one of <a href="#Taiga.LinearSolver"><code>LinearSolver</code></a> types.</p><p>Following statistics are defined by default:</p><ul><li><code>:converged</code> </li><li><code>:status</code></li><li><code>:residual</code></li><li><code>:residual_norm_x₀</code></li><li><code>:niter</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L48-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.ModalSplines"><a class="docstring-binding" href="#Taiga.ModalSplines"><code>Taiga.ModalSplines</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ModalSplines &lt;: DataApproximationMethod</code></pre><p>Method to approximate patch data as separable functions using (ho)svd method and spline interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/approximation.jl#L27-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.Model"><a class="docstring-binding" href="#Taiga.Model"><code>Taiga.Model</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Model</code></pre><p>Concrete models derive from this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/models.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.NonnegativeCanonicalPolyadic"><a class="docstring-binding" href="#Taiga.NonnegativeCanonicalPolyadic"><code>Taiga.NonnegativeCanonicalPolyadic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonnegativeCanonicalPolyadic &lt;: DataApproximationMethod</code></pre><p>Method to approximate patch data in <code>R₊</code> as positive separable functions using the non-negative Canonical polyadic decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/approximation.jl#L19-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.Preconditioner"><a class="docstring-binding" href="#Taiga.Preconditioner"><code>Taiga.Preconditioner</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Preconditioner{Dim,T}</code></pre><p>Concrete preconditioners derive from this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.TaigaCG"><a class="docstring-binding" href="#Taiga.TaigaCG"><code>Taiga.TaigaCG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TaigaCG{T, L}</code></pre><p>Linear solver implementing the Conjugate Gradient method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L144-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.TaigaIPCG"><a class="docstring-binding" href="#Taiga.TaigaIPCG"><code>Taiga.TaigaIPCG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TaigaIPCG{T, L, P}</code></pre><p>Linear solver implementing the inexactly preconditioned Conjugate Gradient method.</p><p><strong>References</strong></p><ol><li>Gene H. Golub and Qiang Ye. Inexact preconditioned conjugate gradient method with inner-outer iteration. SIAM J. Sci. Comput., 21(4):1305–1320, December 1999.</li><li>Andrew V Knyazev and Ilya Lashuk. Steepest descent and conjugate gradient methods with variable preconditioning. SIAM Journal on Matrix Analysis and Applications, 29(4):1267–1280, 2008.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L351-L359">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.TaigaPCG"><a class="docstring-binding" href="#Taiga.TaigaPCG"><code>Taiga.TaigaPCG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TaigaPCG{T, L, P}</code></pre><p>Linear solver implementing the preconditioned Conjugate Gradient method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L241-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.TargetSpace"><a class="docstring-binding" href="#Taiga.TargetSpace"><code>Taiga.TargetSpace</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const TargetSpace{T} = UnivariateSplines.SplineSpace{T}</code></pre><p>Alias for <code>UnivariateSplines.SplineSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/assembly.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.TestSpace"><a class="docstring-binding" href="#Taiga.TestSpace"><code>Taiga.TestSpace</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const TestSpace{T} = UnivariateSplines.SplineSpace{T}</code></pre><p>Alias for <code>UnivariateSplines.SplineSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/assembly.jl#L11-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.VTKHigherOrderDegrees"><a class="docstring-binding" href="#Taiga.VTKHigherOrderDegrees"><code>Taiga.VTKHigherOrderDegrees</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VTKHigherOrderDegrees{Dim, T}</code></pre><p>An immutable sparse container for <code>WriteVTK</code> higher order degrees array.</p><p>This container acts like an array of size <code>(3, ncells)</code> with repeated columns and supports indexing and views.</p><p><strong>Fields:</strong></p><ul><li><code>degrees::NTuple{Dim, T}</code>: cell degrees</li><li><code>ncells::Int</code>: number of Bezier cells</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L568-L579">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.Wachspress"><a class="docstring-binding" href="#Taiga.Wachspress"><code>Taiga.Wachspress</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ModalSpline &lt;: DataApproximationMethod</code></pre><p>Method to approximate patch data at quadrature points using Wachspress algorithms. Works only for data arrays with positive entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/approximation.jl#L35-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{S}, Tuple{T}, Tuple{KroneckerProductAggregate{T, S} where S&lt;:(KroneckerProducts.KroneckerProduct{T}), S}} where {T, S&lt;:(AbstractVector)}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{S}, Tuple{T}, Tuple{KroneckerProductAggregate{T, S} where S&lt;:(KroneckerProducts.KroneckerProduct{T}), S}} where {T, S&lt;:(AbstractVector)}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(K::KroneckerProductAggregate, v::S)</code></pre><p>Compute <code>K.K[1] * v + K.K[2] * v + ... + K.K[end] * v</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>K</code>: collection of Kronecker products</li><li><code>v</code>: vector to multiply with</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckeraggregate.jl#L72-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.adjoint-Tuple{KroneckerProductAggregate}"><a class="docstring-binding" href="#Base.adjoint-Tuple{KroneckerProductAggregate}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearAlgebra.adjoint(K::KroneckerProductAggregate)</code></pre><p>Returns an adjoint <code>KroneckerProductAggregate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckeraggregate.jl#L97-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getproperty-Tuple{LinearSolverStatistics, Symbol}"><a class="docstring-binding" href="#Base.getproperty-Tuple{LinearSolverStatistics, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getproperty(A::LinearSolverStatistics, field::Symbol)</code></pre><p>Returns <code>field</code> in <code>A</code> (actually the value associated with key <code>field</code> in <code>A.data</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L90-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.propertynames-Tuple{LinearSolverStatistics}"><a class="docstring-binding" href="#Base.propertynames-Tuple{LinearSolverStatistics}"><code>Base.propertynames</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.propertynames(A::LinearSolverStatistics)</code></pre><p>Returns all property names of <code>A</code> (keys in <code>A.data</code>!). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L71-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.push!-Union{Tuple{S}, Tuple{T}, Tuple{KroneckerProductAggregate{T, S} where S&lt;:(KroneckerProducts.KroneckerProduct{T}), S}} where {T, S&lt;:(KroneckerProducts.KroneckerProduct{T})}"><a class="docstring-binding" href="#Base.push!-Union{Tuple{S}, Tuple{T}, Tuple{KroneckerProductAggregate{T, S} where S&lt;:(KroneckerProducts.KroneckerProduct{T}), S}} where {T, S&lt;:(KroneckerProducts.KroneckerProduct{T})}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.push!(K::KroneckerProductAggregate{T}, k::S) where {T,S&lt;:KroneckerProduct{T}}</code></pre><p>Adds a Kronecker product matrix to the collection of Kronecker products in <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckeraggregate.jl#L61-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.setproperty!-Tuple{LinearSolverStatistics, Symbol, Any}"><a class="docstring-binding" href="#Base.setproperty!-Tuple{LinearSolverStatistics, Symbol, Any}"><code>Base.setproperty!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.setproperty!(A::LinearSolverStatistics, field::Symbol, value)</code></pre><p>Sets <code>field</code> in <code>A</code> (actually <code>A.data[field]</code>) to <code>value</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>A</code>: statistics container</li><li><code>field</code>: field to set (a key in <code>data</code>)</li><li><code>value</code>: value to set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L78-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.isposdef-Union{Tuple{H}, Tuple{T}, Tuple{Dim}} where {Dim, T, H&lt;:(HyperPowerPreconditioner{Dim, T, A, B} where {A&lt;:LinearOperatorApproximation{Dim, T}, B&lt;:Preconditioner{Dim, T}})}"><a class="docstring-binding" href="#LinearAlgebra.isposdef-Union{Tuple{H}, Tuple{T}, Tuple{Dim}} where {Dim, T, H&lt;:(HyperPowerPreconditioner{Dim, T, A, B} where {A&lt;:LinearOperatorApproximation{Dim, T}, B&lt;:Preconditioner{Dim, T}})}"><code>LinearAlgebra.isposdef</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearAlgebra.isposdef(P::H)</code></pre><p>Returns <code>true</code> if <code>σ(inv(P₀)A) ⊂ (0,2)</code> and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L590-L594">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.opnorm-Union{Tuple{K}, Tuple{T}, Tuple{Dim}} where {Dim, T&lt;:Real, K&lt;:(KroneckerProducts.KroneckerProduct{T, 2, Dim})}"><a class="docstring-binding" href="#LinearAlgebra.opnorm-Union{Tuple{K}, Tuple{T}, Tuple{Dim}} where {Dim, T&lt;:Real, K&lt;:(KroneckerProducts.KroneckerProduct{T, 2, Dim})}"><code>LinearAlgebra.opnorm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearAlgebra.opnorm(A::K) where {Dim,T&lt;:Real,K&lt;:KroneckerProduct{T,2,Dim}}</code></pre><p>Returns the operator norm <code>‖A‖₂</code> of a Kronecker product using Kronecker product eigenvalue decomposition of <code>AᵀA</code> which is fast.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/base.jl#L70-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.apply_particular_solution"><a class="docstring-binding" href="#Taiga.apply_particular_solution"><code>Taiga.apply_particular_solution</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_particular_solution</code></pre><p>Each model module implements its own method for <a href="#Taiga.apply_particular_solution"><code>apply_particular_solution</code></a>, which adds particular solution to homogeneous solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/models.jl#L60-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.approximate_patch_data"><a class="docstring-binding" href="#Taiga.approximate_patch_data"><code>Taiga.approximate_patch_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">approximate_patch_data</code></pre><p>Methods implementing patch data approximation algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/approximation.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.approximate_patch_data-Union{Tuple{E}, Tuple{S2}, Tuple{S1}, Tuple{E, Vararg{Any}}} where {S1, S2, E&lt;:(AbstractMappings.EvaluationSet{S1, S2})}"><a class="docstring-binding" href="#Taiga.approximate_patch_data-Union{Tuple{E}, Tuple{S2}, Tuple{S1}, Tuple{E, Vararg{Any}}} where {S1, S2, E&lt;:(AbstractMappings.EvaluationSet{S1, S2})}"><code>Taiga.approximate_patch_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">approximate_patch_data(C::E, args; method::Type{&lt;:DataApproximationMethod}, kwargs) where {S1,S2,E&lt;:EvaluationSet{S1,S2}}</code></pre><p>Approximate patch data using <code>method</code>. Calls implementation of <code>approximation_patch_data</code> for <code>method</code> with positional arguments <code>args</code> and keyword arguments <code>kwargs</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>C</code>: patch data as <code>IgaFormation.EvaluationSet</code></li><li><code>args</code>: positional arguments to method</li><li><code>method</code>: approximation method</li><li><code>kwargs</code>: keyword arguments to method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/approximation.jl#L52-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.approximate_patch_data-Union{Tuple{E}, Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Type{&lt;:CanonicalPolyadic}, E}} where {T, S1, S2, E&lt;:(AbstractMappings.EvaluationSet{S1, S2})}"><a class="docstring-binding" href="#Taiga.approximate_patch_data-Union{Tuple{E}, Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Type{&lt;:CanonicalPolyadic}, E}} where {T, S1, S2, E&lt;:(AbstractMappings.EvaluationSet{S1, S2})}"><code>Taiga.approximate_patch_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">approximate_patch_data(::Type{&lt;:CanonicalPolyadic}, C::E; tol::T=10e-1, rank::Int=1, ntries::Int=10) where {Dim,S1,S2,E&lt;:EvaluationSet{S1,S2},T}</code></pre><p>Returns an array of size <code>rank × S1 × S2</code> of Vector tuples of length <code>Dim</code> for each data array in <code>C</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>C</code>: patch data as <code>IgaFormation.EvaluationSet</code></li><li><code>tol</code>: cp tolerance</li><li><code>rank</code>: number of cp modes</li><li><code>ntries</code>: number of attempts to compute the CP decomposition per block</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/approximation.jl#L348-L358">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.approximate_patch_data-Union{Tuple{T}, Tuple{E}, Tuple{S2}, Tuple{S1}, Tuple{Dim}, Tuple{Type{&lt;:ModalSplines}, E}} where {Dim, S1, S2, E&lt;:(AbstractMappings.EvaluationSet{S1, S2}), T}"><a class="docstring-binding" href="#Taiga.approximate_patch_data-Union{Tuple{T}, Tuple{E}, Tuple{S2}, Tuple{S1}, Tuple{Dim}, Tuple{Type{&lt;:ModalSplines}, E}} where {Dim, S1, S2, E&lt;:(AbstractMappings.EvaluationSet{S1, S2}), T}"><code>Taiga.approximate_patch_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">approximate_patch_data(::Type{&lt;:ModalSplines}, C::E; S::NTuple{Dim,SplineSpace{T}}, rank::Int=1) where {Dim,S1,S2,E&lt;:EvaluationSet{S1,S2},T}</code></pre><p>Returns an array of size <code>rank × S1 × S2</code> of Bspline tuples of length <code>Dim</code> for each data array in <code>C</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>C</code>: patch data as <code>IgaFormation.EvaluationSet</code></li><li><code>spaces</code>: tuple of univariate interpolation spline spaces</li><li><code>rank</code>: approximation rank</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/approximation.jl#L170-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.bezier_basis_dimension-Union{Tuple{CartesianProducts.TensorProduct{Dim, UnivariateSplines.SplineSpace{T}}}, Tuple{T}, Tuple{Dim}} where {Dim, T}"><a class="docstring-binding" href="#Taiga.bezier_basis_dimension-Union{Tuple{CartesianProducts.TensorProduct{Dim, UnivariateSplines.SplineSpace{T}}}, Tuple{T}, Tuple{Dim}} where {Dim, T}"><code>Taiga.bezier_basis_dimension</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bezier_basis_dimension(S::TensorProduct{Dim, SplineSpace{T}})</code></pre><p>Returns Bezier basis dimension if extracted from <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L11-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.droptol!-Union{Tuple{S}, Tuple{T}} where {T, S&lt;:(KroneckerProductAggregate{T, S} where S&lt;:(KroneckerProducts.KroneckerProduct{T}))}"><a class="docstring-binding" href="#Taiga.droptol!-Union{Tuple{S}, Tuple{T}} where {T, S&lt;:(KroneckerProductAggregate{T, S} where S&lt;:(KroneckerProducts.KroneckerProduct{T}))}"><code>Taiga.droptol!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">droptol!(K::S; rtol = √(eps(T)))</code></pre><p>Drop contributions in <code>K = {K₁, K₂, ...}</code> for which the relative operator norm <code>‖Kₖ‖₂ / || ‖Kₘₐₓ‖₂</code> is less then <code>rtol</code>, where for <code>Kₖ ∈ K</code> we find <code>Kₘₐₓ = argmax ‖Kₖ‖₂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckeraggregate.jl#L106-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.extreme_eigenvalues-Union{Tuple{L}, Tuple{T}} where {T, L&lt;:LinearMaps.LinearMap}"><a class="docstring-binding" href="#Taiga.extreme_eigenvalues-Union{Tuple{L}, Tuple{T}} where {T, L&lt;:LinearMaps.LinearMap}"><code>Taiga.extreme_eigenvalues</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extreme_eigenvalues(A::L; tol::T = 0.1, restarts::Int=200) where {T,L&lt;:LinearMap}</code></pre><p>Compute extreme eigenvalues of a linear map <code>A</code>. Uses <code>ArnoldiMethod</code>. The tolerance <code>tol</code> can be helpful if <code>ArnoldiMethod</code> converges to more then one maximum or minimum eigenvalue. Checks for complex eigenvalues are performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/base.jl#L91-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.forcing"><a class="docstring-binding" href="#Taiga.forcing"><code>Taiga.forcing</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">forcing</code></pre><p>Each model module implements its own method for <a href="#Taiga.forcing"><code>forcing</code></a>, which returns the right hand side vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/models.jl#L52-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.forcing!"><a class="docstring-binding" href="#Taiga.forcing!"><code>Taiga.forcing!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">forcing!</code></pre><p>Each model module implements its own method for <a href="#Taiga.forcing!"><code>forcing!</code></a>, which updates the right hand side vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/models.jl#L44-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.get_bezier_basis_indices-Tuple{UnivariateSplines.SplineSpace, Integer}"><a class="docstring-binding" href="#Taiga.get_bezier_basis_indices-Tuple{UnivariateSplines.SplineSpace, Integer}"><code>Taiga.get_bezier_basis_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_bezier_basis_indices(S::SplineSpace, e::Integer)</code></pre><p>Computes univariate basis indices of a Bezier basis corresponding to Bspline space <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.get_system_matrix_quadrule-Tuple{UnivariateSplines.SplineSpace{T} where T, UnivariateSplines.SplineSpace{T} where T}"><a class="docstring-binding" href="#Taiga.get_system_matrix_quadrule-Tuple{UnivariateSplines.SplineSpace{T} where T, UnivariateSplines.SplineSpace{T} where T}"><code>Taiga.get_system_matrix_quadrule</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_system_matrix_quadrule(S::TargetSpace, V::TestSpace)</code></pre><p>Returns a univariate <code>PatchRule</code> for a pair of spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/assembly.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.hyperpower_eigenvalues_after_n_iterations-Tuple{T} where T"><a class="docstring-binding" href="#Taiga.hyperpower_eigenvalues_after_n_iterations-Tuple{T} where T"><code>Taiga.hyperpower_eigenvalues_after_n_iterations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hyperpower_eigenvalues_after_n_iterations(λ::T; n::Int)</code></pre><p>For a set of eigenvalues <code>λ</code> return the corresponding eigenvalues after <code>n</code> further updates of the Ben-Israel-Cohen iteration.</p><p>Transformation rule applies for <code>λ</code> after first update. The upper bound for <code>λ</code> after first update is 1.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; λ₀ = hyperpower_extreme_eigenvalues(P; n=0, tol=10e-5)
(0.023145184193109333, 1.9749588237991926)

julia&gt; λ₁ = hyperpower_extreme_eigenvalues(P; n=1, tol=10e-5)
(0.045754651575638426, 0.9999899575917253)

julia&gt; hyperpower_extreme_eigenvalues(P; n=5, tol=10e-5)
(0.5273271247385951, 0.9999962548752878)

julia&gt; hyperpower_eigenvalues_after_n_iterations(λ₁; n=4)
(0.5273268941262143, 1.0)

julia&gt; hyperpower_eigenvalues_after_n_iterations(λ₀; n=1)
(0.0457546604483684, 0.049592390484542115)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L490-L516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.hyperpower_extreme_eigenvalues-Union{Tuple{H}, Tuple{T}, Tuple{Dim}} where {Dim, T, H&lt;:(HyperPowerPreconditioner{Dim, T, A, B} where {A&lt;:LinearOperatorApproximation{Dim, T}, B&lt;:Preconditioner{Dim, T}})}"><a class="docstring-binding" href="#Taiga.hyperpower_extreme_eigenvalues-Union{Tuple{H}, Tuple{T}, Tuple{Dim}} where {Dim, T, H&lt;:(HyperPowerPreconditioner{Dim, T, A, B} where {A&lt;:LinearOperatorApproximation{Dim, T}, B&lt;:Preconditioner{Dim, T}})}"><code>Taiga.hyperpower_extreme_eigenvalues</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hyperpower_extreme_eigenvalues(P::H; n::Int=1, tol::T=√eps(T)) where {Dim,T,H&lt;:HyperPowerPreconditioner{Dim,T}}</code></pre><p>Compute the extreme eigenvalues of <code>inv(Pₙ)A</code>, i.e. return a tuple <code>(λmin, λmax)</code> in <code>n</code>th iteration.</p><p>In the case of eigenvalue clustering, i.e. around the value of 1, it might be necessary to choose lower <code>tol</code>.</p><p>Example:</p><pre><code class="nohighlight hljs">julia
julia&gt; λ₀ = hyperpower_extreme_eigenvalues(P; n=0, tol=10e-5)
(0.023145184193109333, 1.9749588237991926)

julia&gt; λ₁ = hyperpower_extreme_eigenvalues(P; n=1, tol=10e-5)
(0.045754651575638426, 0.9999899575917253)

julia&gt; hyperpower_extreme_eigenvalues(P; n=2, tol=10e-5)
(0.08941582990237358, 0.9999916150622586)

julia&gt; hyperpower_extreme_eigenvalues(P; n=3, tol=10e-5)
(0.1708364549356042, 1.0000016638364837)

julia&gt; hyperpower_extreme_eigenvalues(P; n=4, tol=10e-5)
(0.3124877477755778, 0.9999984021406245)

julia&gt; hyperpower_extreme_eigenvalues(P; n=5, tol=10e-5)
(0.5273271247385951, 0.9999962548752878)

julia&gt; hyperpower_eigenvalues_after_n_iterations(λ₁; n=2)
(0.17083641016503434, 1.0)

julia&gt; hyperpower_eigenvalues_after_n_iterations(λ₁; n=3)
(0.31248774129199286, 1.0)

julia&gt; hyperpower_eigenvalues_after_n_iterations(λ₁; n=4)
(0.5273268941262143, 1.0)

julia&gt; hyperpower_eigenvalues_after_n_iterations(λ₀; n=1)
(0.0457546604483684, 0.049592390484542115)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L522-L562">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.hyperpower_initial_preconditioner-Union{Tuple{H}, Tuple{T}, Tuple{Dim}} where {Dim, T, H&lt;:(HyperPowerPreconditioner{Dim, T, A, B} where {A&lt;:LinearOperatorApproximation{Dim, T}, B&lt;:Preconditioner{Dim, T}})}"><a class="docstring-binding" href="#Taiga.hyperpower_initial_preconditioner-Union{Tuple{H}, Tuple{T}, Tuple{Dim}} where {Dim, T, H&lt;:(HyperPowerPreconditioner{Dim, T, A, B} where {A&lt;:LinearOperatorApproximation{Dim, T}, B&lt;:Preconditioner{Dim, T}})}"><code>Taiga.hyperpower_initial_preconditioner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hyperpower_initial_preconditioner(P::H)</code></pre><p>Returns the initial preconditioner that was used in the construction of <code>P</code>, e.g. <a href="#Taiga.FastDiagonalization"><code>FastDiagonalization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L477-L481">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.inner_solver_convergence-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><a class="docstring-binding" href="#Taiga.inner_solver_convergence-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><code>Taiga.inner_solver_convergence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inner_solver_convergence(P::S) where {S&lt;:Union{InnerCG, InnerPCG}}</code></pre><p>Returns a vector booleans indicating convergence in last applications of <a href="#Taiga.InnerPCG"><code>InnerPCG</code></a> preconditioner.</p><p>See <a href="#Taiga.reset_inner_solver_history!-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><code>reset_inner_solver_history!</code></a> to reset history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L389-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.inner_solver_niters-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><a class="docstring-binding" href="#Taiga.inner_solver_niters-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><code>Taiga.inner_solver_niters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inner_solver_niter(P::S) where {S&lt;:Union{InnerCG, InnerPCG}}</code></pre><p>Returns a vector with numbers of iterations in last applications of <a href="#Taiga.InnerCG"><code>InnerCG</code></a> and <a href="#Taiga.InnerPCG"><code>InnerPCG</code></a> preconditioner.</p><p>See <a href="#Taiga.reset_inner_solver_history!-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><code>reset_inner_solver_history!</code></a> to reset history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L365-L372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.inner_solver_residuals-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><a class="docstring-binding" href="#Taiga.inner_solver_residuals-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><code>Taiga.inner_solver_residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inner_solver_residuals(P::S) where {S&lt;:Union{InnerCG, InnerPCG}}</code></pre><p>Returns a vector with residuals in last applications of <a href="#Taiga.InnerPCG"><code>InnerPCG</code></a> preconditioner. See <a href="#Taiga.reset_inner_solver_history!-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><code>reset_inner_solver_history!</code></a> to reset history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L378-L383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.linear_operator"><a class="docstring-binding" href="#Taiga.linear_operator"><code>Taiga.linear_operator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linear_operator()</code></pre><p>Returns a linear operator for a model. Each model module implements this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/models.jl#L29-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.linear_operator_approximation"><a class="docstring-binding" href="#Taiga.linear_operator_approximation"><code>Taiga.linear_operator_approximation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linear_operator_approximation()</code></pre><p>Returns a linear operator approximation for a model. Some model modules implements this. Linear operator approximations are cheap to apply and useful in the context of preconditioning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/models.jl#L36-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.linsolve!"><a class="docstring-binding" href="#Taiga.linsolve!"><code>Taiga.linsolve!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linsolve!</code></pre><p>Linear solvers implement this method. Typically, the syntax is <code>linsolve!(solver, rhs; kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L23-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.linsolve!-Union{Tuple{L}, Tuple{T}, Tuple{TaigaCG{T, L}, Vector{T}}} where {T, L}"><a class="docstring-binding" href="#Taiga.linsolve!-Union{Tuple{L}, Tuple{T}, Tuple{TaigaCG{T, L}, Vector{T}}} where {T, L}"><code>Taiga.linsolve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linsolve!(solver::TaigaCG{T, L}, b::Vector{T}; x0::Vector{T} = zeros(size(solver.A, 2)))</code></pre><p>Solve the linear system <code>A x = b</code> using <a href="#Taiga.TaigaCG"><code>TaigaCG</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>solver</code>: solver context</li><li><code>b</code>: rhs vector</li><li><code>x0</code>: initial guess</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L174-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.linsolve!-Union{Tuple{L}, Tuple{T}, Tuple{TaigaIPCG{T, L}, Vector{T}}} where {T, L}"><a class="docstring-binding" href="#Taiga.linsolve!-Union{Tuple{L}, Tuple{T}, Tuple{TaigaIPCG{T, L}, Vector{T}}} where {T, L}"><code>Taiga.linsolve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linsolve!(solver::TaigaCG{T, L}, b::Vector{T}; x0::Vector{T} = zeros(size(solver.A, 2)))</code></pre><p>Solve the linear system <code>A x = b</code> using <a href="#Taiga.TaigaIPCG"><code>TaigaIPCG</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>solver</code>: solver context</li><li><code>b</code>: rhs vector</li><li><code>x0</code>: initial guess</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L392-L401">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.linsolve!-Union{Tuple{L}, Tuple{T}, Tuple{TaigaPCG{T, L}, Vector{T}}} where {T, L}"><a class="docstring-binding" href="#Taiga.linsolve!-Union{Tuple{L}, Tuple{T}, Tuple{TaigaPCG{T, L}, Vector{T}}} where {T, L}"><code>Taiga.linsolve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linsolve!(solver::TaigaPCG{T, L}, b::Vector{T}; x0::Vector{T} = zeros(size(solver.A, 2)))</code></pre><p>Solve the linear system <code>A x = b</code> using <a href="#Taiga.TaigaPCG"><code>TaigaPCG</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>solver</code>: solver context</li><li><code>b</code>: rhs vector</li><li><code>x0</code>: initial guess</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L278-L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.reset!-Tuple{KroneckerFactory}"><a class="docstring-binding" href="#Taiga.reset!-Tuple{KroneckerFactory}"><code>Taiga.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset!(f::KroneckerFactory)</code></pre><p>Reset <a href="#Taiga.KroneckerProductAggregate"><code>KroneckerProductAggregate</code></a> collection in <a href="#KroneckerFactory"><code>KroneckerFactory</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/kroneckerfactory.jl#L74-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.reset_inner_solver_history!-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><a class="docstring-binding" href="#Taiga.reset_inner_solver_history!-Tuple{S} where S&lt;:Union{InnerCG, InnerPCG}"><code>Taiga.reset_inner_solver_history!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset_inner_solver_niter_history!(P::S) where {S&lt;:Union{InnerCG, InnerPCG}}</code></pre><p>Reset history in <a href="#Taiga.InnerCG"><code>InnerCG</code></a> and <a href="#Taiga.InnerPCG"><code>InnerPCG</code></a> preconditioner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/preconditioning.jl#L352-L356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.system_matrix_integrand-Union{Tuple{T}, Tuple{UnivariateSplines.SplineSpace{T}, UnivariateSplines.SplineSpace{T}}, Tuple{UnivariateSplines.SplineSpace{T}, UnivariateSplines.SplineSpace{T}, Int64}, Tuple{UnivariateSplines.SplineSpace{T}, UnivariateSplines.SplineSpace{T}, Int64, Int64}} where T&lt;:Real"><a class="docstring-binding" href="#Taiga.system_matrix_integrand-Union{Tuple{T}, Tuple{UnivariateSplines.SplineSpace{T}, UnivariateSplines.SplineSpace{T}}, Tuple{UnivariateSplines.SplineSpace{T}, UnivariateSplines.SplineSpace{T}, Int64}, Tuple{UnivariateSplines.SplineSpace{T}, UnivariateSplines.SplineSpace{T}, Int64, Int64}} where T&lt;:Real"><code>Taiga.system_matrix_integrand</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">system_matrix_integrand(S::TargetSpace{T}, V::TestSpace{T}, k::Int = 1, l::Int = 1; x::T)</code></pre><p>Evaluates to the integrand of a system matrix <code>∫ s(ξ)v(ξ) dΩ</code> for <code>ξ = x</code> where <code>s ∈ S</code> and <code>v ∈ V</code>.</p><p>This is useful i.e. in the definition of boundary integrals on Cartesian grids.</p><p><strong>Arguments:</strong></p><ul><li><code>S</code>: a <code>UnivariateSplines.SplineSpace</code> as target space</li><li><code>V</code>: a <code>UnivariateSplines.SplineSpace</code> as test space</li><li><code>k</code>: derivative order on target space</li><li><code>l</code>: derivative order on test space</li><li><code>x</code>: evaluation point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/assembly.jl#L101-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.update_linear_solver_statistics!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:LinearSolver"><a class="docstring-binding" href="#Taiga.update_linear_solver_statistics!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:LinearSolver"><code>Taiga.update_linear_solver_statistics!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_linear_solver_statistics!(solver::S)</code></pre><p>For <code>η = √rᵀr</code> and <code>η₀ =  √r₀ᵀr₀</code> and check <code>η &lt; atol</code>, <code>η₀ &lt; rtol</code> and if number of iterations is equal to <code>itmax</code>. Sets <code>solver.stats.converged</code> and <code>solver.stats.status</code> accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/linearsolvers.jl#L112-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_bezier_cell_degree-Union{Tuple{BezierExtractionContext{Dim, T}}, Tuple{T}, Tuple{Dim}} where {Dim, T}"><a class="docstring-binding" href="#Taiga.vtk_bezier_cell_degree-Union{Tuple{BezierExtractionContext{Dim, T}}, Tuple{T}, Tuple{Dim}} where {Dim, T}"><code>Taiga.vtk_bezier_cell_degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_bezier_cell_degree(S::BezierExtractionContext{Dim, T}) where {Dim,T&lt;:SplineSpace}</code></pre><p>Computes univariate degrees for a Bezier cell in a <code>BezierExtractionContext</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L349-L353">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_bezier_cell_degree-Union{Tuple{CartesianProducts.TensorProduct{Dim, T}}, Tuple{T}, Tuple{Dim}} where {Dim, T&lt;:UnivariateSplines.SplineSpace}"><a class="docstring-binding" href="#Taiga.vtk_bezier_cell_degree-Union{Tuple{CartesianProducts.TensorProduct{Dim, T}}, Tuple{T}, Tuple{Dim}} where {Dim, T&lt;:UnivariateSplines.SplineSpace}"><code>Taiga.vtk_bezier_cell_degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_bezier_cell_degree(S::TensorProduct{Dim, T}) where {Dim,T&lt;:SplineSpace}</code></pre><p>Computes a tuple of univariate degrees for a Bezier cell extracted from a tensor product spline space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L340-L344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_bezier_cells-Tuple{BezierExtractionContext}"><a class="docstring-binding" href="#Taiga.vtk_bezier_cells-Tuple{BezierExtractionContext}"><code>Taiga.vtk_bezier_cells</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_bezier_cells(B::VTKBezierExtractionContext)</code></pre><p>Collects all Bezier cells in <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L315-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_bezier_degrees-Tuple{BezierExtractionContext}"><a class="docstring-binding" href="#Taiga.vtk_bezier_degrees-Tuple{BezierExtractionContext}"><code>Taiga.vtk_bezier_degrees</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_bezier_degrees(B::VTKBezierExtraction)</code></pre><p>Returns an immutable sparse array container of type <code>VTKHigherOrderDegrees</code> with cell degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L619-L623">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_cell_connectivity-Union{Tuple{BezierExtractionContext{Dim, T}}, Tuple{T}, Tuple{Dim}} where {Dim, T}"><a class="docstring-binding" href="#Taiga.vtk_cell_connectivity-Union{Tuple{BezierExtractionContext{Dim, T}}, Tuple{T}, Tuple{Dim}} where {Dim, T}"><code>Taiga.vtk_cell_connectivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_cell_connectivity(B::BezierExtractionContext{Dim, T})</code></pre><p>Returns cell connectivity for a <a href="#Taiga.BezierExtractionContext"><code>BezierExtractionContext</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L137-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_cell_point_indices-Union{Tuple{Tuple{Vararg{Int64, Dim}}}, Tuple{Dim}} where Dim"><a class="docstring-binding" href="#Taiga.vtk_cell_point_indices-Union{Tuple{Tuple{Vararg{Int64, Dim}}}, Tuple{Dim}} where Dim"><code>Taiga.vtk_cell_point_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_cell_point_indices(order::NTuple{Dim, Int}) where {Dim}</code></pre><p>Computes point indices of a reference VTK Bezier cell with points indexed using Cartesian indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L435-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_cell_type-Tuple{BezierExtractionContext{1}}"><a class="docstring-binding" href="#Taiga.vtk_cell_type-Tuple{BezierExtractionContext{1}}"><code>Taiga.vtk_cell_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_cell_type(::VTKBezierExtraction{Dim}) where {Dim}</code></pre><p>Returns a Bezier cell type based on <code>Dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L358-L362">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_control_net_cells-Tuple{Vector{Tuple{Int64, Int64}}}"><a class="docstring-binding" href="#Taiga.vtk_control_net_cells-Tuple{Vector{Tuple{Int64, Int64}}}"><code>Taiga.vtk_control_net_cells</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_control_net_cells(connectivity::Vector{Tuple{Int, Int}})</code></pre><p>Returns a vector of <code>VTKCellTypes.VTK_LINE</code> cells given a vector of point connectivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L417-L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_control_net_connectivity-Union{Tuple{AbstractMappings.GeometricMapping{Dim}}, Tuple{Dim}} where Dim"><a class="docstring-binding" href="#Taiga.vtk_control_net_connectivity-Union{Tuple{AbstractMappings.GeometricMapping{Dim}}, Tuple{Dim}} where Dim"><code>Taiga.vtk_control_net_connectivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_control_net_connectivity(mapping::GeometricMapping{Dim})</code></pre><p>Generates a list of connectivity tuples for all edges of a control net based on the size of the control points grid in mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L377-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_control_net_points-Union{Tuple{AbstractMappings.GeometricMapping{Dim, Codim}}, Tuple{Codim}, Tuple{Dim}} where {Dim, Codim}"><a class="docstring-binding" href="#Taiga.vtk_control_net_points-Union{Tuple{AbstractMappings.GeometricMapping{Dim, Codim}}, Tuple{Codim}, Tuple{Dim}} where {Dim, Codim}"><code>Taiga.vtk_control_net_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_control_net_points(mapping::GeometricMapping{Dim, Codim})</code></pre><p>Returns vectorized NURBS coefficients (for <code>WriteVTK</code> purposes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L409-L414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_control_net_weights-Tuple{AbstractMappings.GeometricMapping}"><a class="docstring-binding" href="#Taiga.vtk_control_net_weights-Tuple{AbstractMappings.GeometricMapping}"><code>Taiga.vtk_control_net_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_control_net_weights(mapping::GeometricMapping)</code></pre><p>Returns vectorized NURBS weights (for <code>WriteVTK</code> purposes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L402-L406">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_extract_bezier_points-Union{Tuple{Codim}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, AbstractMappings.Field{Dim, Codim}}} where {Dim, Codim}"><a class="docstring-binding" href="#Taiga.vtk_extract_bezier_points-Union{Tuple{Codim}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, AbstractMappings.Field{Dim, Codim}}} where {Dim, Codim}"><code>Taiga.vtk_extract_bezier_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_extract_bezier_points(B::BezierExtractionContext{Dim}, F::Field{Dim, Codim})</code></pre><p>Returns Bezier points of a Bspline field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L276-L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_extract_bezier_points-Union{Tuple{Codim}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, AbstractMappings.GeometricMapping{Dim, Codim}}} where {Dim, Codim}"><a class="docstring-binding" href="#Taiga.vtk_extract_bezier_points-Union{Tuple{Codim}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, AbstractMappings.GeometricMapping{Dim, Codim}}} where {Dim, Codim}"><code>Taiga.vtk_extract_bezier_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_extract_bezier_points(B::BezierExtractionContext{Dim}, F::GeometricMapping{Dim, Codim}; bezier_weights = nothing, vectorize = true)</code></pre><p>Returns Bezier weights from a NURBS geometric mapping.</p><p>If <code>vectorize</code> is <code>true</code> the result is a tuple of vector views to the points.</p><p>Precomputed Bezier weights can be passed in <code>bezier_weights</code> explicitly. If not provided, these will be computed automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L258-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_extract_bezier_points-Union{Tuple{M}, Tuple{T2}, Tuple{T1}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, M}} where {Dim, T1, T2, M&lt;:IgaBase.AbstractMapping{Dim, T1, T2}}"><a class="docstring-binding" href="#Taiga.vtk_extract_bezier_points-Union{Tuple{M}, Tuple{T2}, Tuple{T1}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, M}} where {Dim, T1, T2, M&lt;:IgaBase.AbstractMapping{Dim, T1, T2}}"><code>Taiga.vtk_extract_bezier_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_extract_bezier_points(B::BezierExtractionContext{Dim}, F::M) where {Dim,Codim,M&lt;:AbstractMapping}</code></pre><p>Returns Bezier points of Galerkin projection of an abstract mapping.</p><p>Consider this a fallback routine: it is used only if the mapping <code>F</code> is not a B-spline or NURBS map. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L293-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_extract_bezier_points-Union{Tuple{T}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim, T}, Array{T, Dim}, Array{T, Dim}, Array{T, Dim}}} where {Dim, T}"><a class="docstring-binding" href="#Taiga.vtk_extract_bezier_points-Union{Tuple{T}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim, T}, Array{T, Dim}, Array{T, Dim}, Array{T, Dim}}} where {Dim, T}"><code>Taiga.vtk_extract_bezier_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_extract_bezier_points(B::BezierExtractionContext{Dim, T}, bezier_weights::Array{T, Dim}, spline_weights::Array{T, Dim}, spline_coeffs::Array{T, Dim})</code></pre><p>Returns Bezier points from NURBS control points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L200-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_extract_bezier_points-Union{Tuple{T}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim, T}, Array{T, Dim}}} where {Dim, T}"><a class="docstring-binding" href="#Taiga.vtk_extract_bezier_points-Union{Tuple{T}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim, T}, Array{T, Dim}}} where {Dim, T}"><code>Taiga.vtk_extract_bezier_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_extract_bezier_points(B::BezierExtractionContext{Dim, T}, spline_coeffs::Array{T, Dim})</code></pre><p>Returns Bezier points from Bspline control points (i.e. without rational weighting).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L231-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_extract_bezier_weights-Union{Tuple{Codim}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, AbstractMappings.GeometricMapping{Dim, Codim}}} where {Dim, Codim}"><a class="docstring-binding" href="#Taiga.vtk_extract_bezier_weights-Union{Tuple{Codim}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, AbstractMappings.GeometricMapping{Dim, Codim}}} where {Dim, Codim}"><code>Taiga.vtk_extract_bezier_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_extract_bezier_weights(B::BezierExtractionContext{Dim}, F::GeometricMapping{Dim, Codim})</code></pre><p>Returns Bezier weights from a NURBS geometric mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L190-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_extract_bezier_weights-Union{Tuple{T}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim, T}, Array{T, Dim}}} where {Dim, T}"><a class="docstring-binding" href="#Taiga.vtk_extract_bezier_weights-Union{Tuple{T}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim, T}, Array{T, Dim}}} where {Dim, T}"><code>Taiga.vtk_extract_bezier_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_extract_bezier_weights(B::BezierExtractionContext{Dim, T}, spline_weights::Array{T, Dim})</code></pre><p>Returns Bezier weights from NURBS weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L164-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_map_linear_indices-Union{Tuple{N}, Tuple{AbstractArray, Tuple{Vararg{Int64, N}}}} where N"><a class="docstring-binding" href="#Taiga.vtk_map_linear_indices-Union{Tuple{N}, Tuple{AbstractArray, Tuple{Vararg{Int64, N}}}} where N"><code>Taiga.vtk_map_linear_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_map_linear_indices(lind::AbstractArray, connectivity::NTuple{N, Int}) where {N}</code></pre><p>Maps linear indices of a Bezier cell index by Cartesian indices based on the connectivity of a reference VTK Bezier cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L424-L429">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_num_cell_vertices-Tuple{BezierExtractionContext}"><a class="docstring-binding" href="#Taiga.vtk_num_cell_vertices-Tuple{BezierExtractionContext}"><code>Taiga.vtk_num_cell_vertices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_num_cell_vertices(B::BezierExtractionContext)</code></pre><p>Returns number of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L333-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_num_cells-Tuple{BezierExtractionContext}"><a class="docstring-binding" href="#Taiga.vtk_num_cells-Tuple{BezierExtractionContext}"><code>Taiga.vtk_num_cells</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_num_cells(B::BezierExtractionContext)</code></pre><p>Returns number of Bezier cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L326-L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_point_index_from_ijk-Tuple{CartesianIndex{1}, Tuple{Int64}}"><a class="docstring-binding" href="#Taiga.vtk_point_index_from_ijk-Tuple{CartesianIndex{1}, Tuple{Int64}}"><code>Taiga.vtk_point_index_from_ijk</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_point_index_from_ijk(inds::CartesianIndex{1}, order::NTuple{2, Int})</code></pre><p>Computes VTK point index based on Cartesian index of a cell point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L552-L556">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_point_index_from_ijk-Tuple{CartesianIndex{2}, Tuple{Int64, Int64}}"><a class="docstring-binding" href="#Taiga.vtk_point_index_from_ijk-Tuple{CartesianIndex{2}, Tuple{Int64, Int64}}"><code>Taiga.vtk_point_index_from_ijk</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_point_index_from_ijk(inds::CartesianIndex{2}, order::NTuple{2, Int})</code></pre><p>Computes VTK point index based on Cartesian index of a cell point.</p><p>Adapted from VTK&#39;s <code>vtkHigherOrderHexahedron::PointIndexFromIJK()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L514-L520">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_point_index_from_ijk-Tuple{CartesianIndex{3}, Tuple{Int64, Int64, Int64}}"><a class="docstring-binding" href="#Taiga.vtk_point_index_from_ijk-Tuple{CartesianIndex{3}, Tuple{Int64, Int64, Int64}}"><code>Taiga.vtk_point_index_from_ijk</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_point_index_from_ijk(inds::CartesianIndex{3}, order::NTuple{3, Int})</code></pre><p>Computes VTK point index based on Cartesian index of a cell point.</p><p>Adapted from VTK&#39;s <code>vtkHigherOrderHexahedron::PointIndexFromIJK()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L450-L456">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_reference_cell_connectivity-Union{Tuple{Array{Int64, Dim}}, Tuple{Dim}} where Dim"><a class="docstring-binding" href="#Taiga.vtk_reference_cell_connectivity-Union{Tuple{Array{Int64, Dim}}, Tuple{Dim}} where Dim"><code>Taiga.vtk_reference_cell_connectivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_reference_cell_connectivity(point_indices::Array{Int, Dim}) where {Dim}</code></pre><p>Computes cell connectivity of a reference VTK Bezier cell with points indexed using Cartesian indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L367-L372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_save_bezier-Union{Tuple{T}, Tuple{String, AbstractMappings.GeometricMapping}} where T&lt;:IgaBase.AbstractMapping"><a class="docstring-binding" href="#Taiga.vtk_save_bezier-Union{Tuple{T}, Tuple{String, AbstractMappings.GeometricMapping}} where T&lt;:IgaBase.AbstractMapping"><code>Taiga.vtk_save_bezier</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_save_bezier(filepath::String, mapping::GeometricMapping; fields::Union{Dict{String,T},Nothing}=nothing) where {T&lt;:AbstractMapping}</code></pre><p>Perform Bezier extraction and save a VTK file with the result.</p><p><code>mapping</code> is a expected to be a NURBS. The optional dictionary <code>fields</code> may contain fields defined by Bsplines.</p><p><strong>Arguments:</strong></p><ul><li><code>filepath</code>: output file path without extension</li><li><code>mapping</code>: geometric mapping</li><li><code>fields</code>: a dictionary of strings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L87-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.vtk_save_control_net-Tuple{String, AbstractMappings.GeometricMapping}"><a class="docstring-binding" href="#Taiga.vtk_save_control_net-Tuple{String, AbstractMappings.GeometricMapping}"><code>Taiga.vtk_save_control_net</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vtk_save_control_net(filepath::String, mapping::GeometricMapping)</code></pre><p>Save a VTK file with the control net of a NURBS geometric mapping. The VTK file will contain a dataset with the NURBS weights per control point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/postprocessing.jl#L120-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.weighted_system_matrix"><a class="docstring-binding" href="#Taiga.weighted_system_matrix"><code>Taiga.weighted_system_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">weighted_system_matrix(S::TargetSpace, V::TestSpace, data::Bspline, k::Int = 1, l::Int = 1)</code></pre><p>Returns a univariate system matrix as in <code>UnivariateSplines.system_matrix</code> but applies a spline weighting function to the test functions.</p><p><strong>Arguments:</strong></p><ul><li><code>S</code>: trial space</li><li><code>V</code>: test space</li><li><code>data</code>: univariate spline weighting function</li><li><code>k</code>: derivative order on trial functions</li><li><code>l</code>: derivarive order on test functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/assembly.jl#L66-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.weighted_system_matrix"><a class="docstring-binding" href="#Taiga.weighted_system_matrix"><code>Taiga.weighted_system_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">weighted_system_matrix(S::TargetSpace, V::TestSpace, data::AbstractVector, k::Int = 1, l::Int = 1)</code></pre><p>Returns a univariate system matrix as in <code>UnivariateSplines.system_matrix</code> but applies weighting to the test function defined by a <code>data</code> vector.</p><p><strong>Arguments:</strong></p><ul><li><code>S</code>: trial space</li><li><code>V</code>: test space</li><li><code>data</code>: vector with weights</li><li><code>k</code>: derivative order on trial functions</li><li><code>l</code>: derivarive order on test functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/assembly.jl#L34-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.ι-Tuple{Int64, Int64}"><a class="docstring-binding" href="#Taiga.ι-Tuple{Int64, Int64}"><code>Taiga.ι</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ι(k::Int, l::Int; val::NTuple{2,Int}=(1,1), dim::Int=3)</code></pre><p>Brief magic function that returns a tuple of integers with length <code>dim</code> where <code>k</code>-th integer is equal to <code>val[1]</code>, <code>l</code>-th integer is equal to <code>val[2]</code> and the rest is zero. If <code>k</code> and <code>l</code> coincide, the values are summed up.</p><p>This is in particular useful to define tuples for test and trial function derivatives in sum factorization loops, e.g.</p><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; ∇²u(k, l) = ι(k, l, dim = 2);

julia&gt; ∇²u(1, 1)
(2, 0)

julia&gt; ∇²u(1, 2)
(1, 1)

julia&gt; ∇²u(2, 1)
(1, 1)

julia&gt; ∇²u(2, 2)
(0, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/base.jl#L39-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Taiga.ι-Tuple{Int64}"><a class="docstring-binding" href="#Taiga.ι-Tuple{Int64}"><code>Taiga.ι</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ι(k::Int; val::Int=1, dim::Int=3)</code></pre><p>Brief magic function that returns a tuple of integers with length <code>dim</code> where <code>k</code>-th integer is equal to <code>val</code> and the rest is zero.</p><p>This is in particular useful to define tuples for test and trial function derivatives in sum factorization loops, e.g.</p><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; u = ι(0, dim = 2);

julia&gt; ∇u(k) = ι(k, dim = 2);

julia&gt; u
(0, 0)

julia&gt; ∇u(1)
(1, 0)

julia&gt; ∇u(2)
(0, 1)

julia&gt; ∇²ₖₖu(k) = ι(k, val=2, dim = 2);

julia&gt; ∇²ₖₖu(1)
(2, 0)

julia&gt; ∇²ₖₖu(2)
(0, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuiteSplines/Taiga.jl/blob/393e0749c8fabd0f557fd9babb23bb03b6914f63/src/base.jl#L3-L35">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="poisson/">Poisson equation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 30 January 2026 18:26">Friday 30 January 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
