var documenterSearchIndex = {"docs":
[{"location":"poisson/#PoissonModule","page":"Poisson equation","title":"PoissonModule","text":"This module implements a Galerkin discretization of the Poisson equation with (non)homogenous Dirichlet and Neumann boundary conditions.\n\n(Image: Poisson on horseshoe domain)\n\n./examples/poisson/horseshoe.jl","category":"section"},{"location":"poisson/#Index","page":"Poisson equation","title":"Index","text":"","category":"section"},{"location":"poisson/#Taiga.FastDiagonalization-Union{Tuple{Poisson{Dim, T, M, V, W} where {M<:(AbstractMappings.GeometricMapping{Dim}), V<:CartesianProducts.TensorProduct{Dim, UnivariateSplines.SplineSpace{T}}, W<:(AbstractMappings.Field{Dim})}}, Tuple{T}, Tuple{Dim}} where {Dim, T}","page":"Poisson equation","title":"Taiga.FastDiagonalization","text":"Taiga.FastDiagonalization(model::Poisson{Dim,T}; method::Type{<:DataApproximationMethod}=Wachspress, kwargs...) where {Dim,T}\n\nConstructs a FastDiagonalization preconditioner using a particular data approximation method. Poisson supports Wachspress and ModalSplines data approximation methods.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#Taiga.FastDiagonalization-Union{Tuple{T}, Tuple{Dim}, Tuple{Type{<:ModalSplines}, Poisson{Dim, T, M, V, W} where {M<:(AbstractMappings.GeometricMapping{Dim}), V<:CartesianProducts.TensorProduct{Dim, UnivariateSplines.SplineSpace{T}}, W<:(AbstractMappings.Field{Dim})}}} where {Dim, T}","page":"Poisson equation","title":"Taiga.FastDiagonalization","text":"Taiga.FastDiagonalization(::Type{<:ModalSplines}, model::Poisson; spaces::NTuple{Dim, SplineSpace{T}})\n\nConstructs a fast diagonalization preconditioner using rank 1 modal splines approximation of model patch data on univariate spline spaces in spaces.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#Taiga.FastDiagonalization-Union{Tuple{T}, Tuple{Dim}, Tuple{Type{<:Wachspress}, Poisson{Dim, T, M, V, W} where {M<:(AbstractMappings.GeometricMapping{Dim}), V<:CartesianProducts.TensorProduct{Dim, UnivariateSplines.SplineSpace{T}}, W<:(AbstractMappings.Field{Dim})}}} where {Dim, T}","page":"Poisson equation","title":"Taiga.FastDiagonalization","text":"Taiga.FastDiagonalization(::Type{<:Wachspress}, model::Poisson; niter::Int)\n\nConstructs a fast diagonalization preconditioner using niter of Wachspress algorithm to approximate patch data.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#Taiga.PoissonModule.LinearOperator","page":"Poisson equation","title":"Taiga.PoissonModule.LinearOperator","text":"LinearOperator{Dim,T,M<:AbstractMatrix{T},V<:AbstractVector{T},B<:KroneckerProduct{T}} <: Taiga.LinearOperator{Dim,T}\n\nLinear operator for the homogeneous system in Poisson model.\n\nFields:\n\nK::M: stiffness matrix\nb::V: rhs vector\nC::B: Kronecker product extraction operator\n\n\n\n\n\n","category":"type"},{"location":"poisson/#Taiga.PoissonModule.LinearOperatorApproximation","page":"Poisson equation","title":"Taiga.PoissonModule.LinearOperatorApproximation","text":"LinearOperatorApproximation{Dim,T} <: Taiga.LinearOperatorApproximation{Dim,T}\n\nLinear operator approximation for the homogeneous system in Poisson model.\n\nFields:\n\nL::KroneckerProductAggregate{T}: Kronecker product aggregate\n\n\n\n\n\n","category":"type"},{"location":"poisson/#Taiga.PoissonModule.MatrixfreeLinearOperator","page":"Poisson equation","title":"Taiga.PoissonModule.MatrixfreeLinearOperator","text":"MatrixfreeLinearOperator{Dim, T, M <: Poisson{Dim, T}, A <: Accessor{Dim}, B <: KroneckerProduct{T}, V <: VectorSumfactoryCache{Dim}} <: Taiga.LinearOperator{Dim,T}\n\nMatrix-free linear operator for the homogeneous system in Poisson model.\n\nFields:\n\nmodel::M: model\nacc::A: patch accessor\nC::B: Kronecker product extraction operator\npullback_body::Function: pullback for the body terms\nsumfact_cache_u::V: sum factorization vector cache\n\n\n\n\n\n","category":"type"},{"location":"poisson/#Taiga.PoissonModule.Poisson","page":"Poisson equation","title":"Taiga.PoissonModule.Poisson","text":"Poisson{Dim,T,M<:GeometricMapping{Dim},V<:ScalarSplineSpace{Dim,T},W<:Field{Dim}} <: Model{Dim,T}\n\nStrong form\n\n-∇ ⋅ (κ∇u) = f      in Ω\n         u = ū      on Γ₁\n    ∇u ⋅ n = t ⋅ n  on Γ₂\n\nWeak form\n\nFind the homogeneous solution uₒ ∈ Sʰ, s.t. ∀v ∈ Sʰ\n\n    ∫ ∇(uₒ - ū) ⋅ ∇v dΩ - ∫ (t ⋅ n) v dΓ₁ = - ∫ f v dΓ\n\nfor the homogeneous problem uₒ = 0 on Γ. The solution\nu ∈ ū ⊕ Sʰ satisfying nonhomogeneous Dirichlet boundary\nconditions is u = uₒ + ū.\n\nNote\n\nThe linear operators Taiga.PoissonModule.LinearOperator and Taiga.PoissonModule.MatrixfreeLinearOperator correspond to the homogeneous problem on the constrained space. The solution of the nonhomogeneous problem is obtained by Taiga.PoissonModule.apply_particular_solution.\n\nFields:\n\nF::M: geometric mapping\nS::V: solution space\nΔ::Partition{Dim,T}: partition of the space\nuʰ::Field: solution field\nūʰ::W: scalar solution field satisfying Dirichlet boundary conditions\nκ::Function: conductivity matrix of size Dim × Dim as function of spatial coordinates\nf::Function: body force as function of spatial coordinates\nt::Function: traction as function of spatial coordinates\n\n\n\n\n\n","category":"type"},{"location":"poisson/#Taiga.PoissonModule.Poisson-Union{Tuple{W}, Tuple{V}, Tuple{M}, Tuple{T}, Tuple{Dim}, Tuple{M, V, SpecialSpaces.ScalarSplineSpaceConstraints{Dim}, W, W, Function, Function, Function}} where {Dim, T, M<:(AbstractMappings.GeometricMapping{Dim}), V<:CartesianProducts.TensorProduct{Dim, UnivariateSplines.SplineSpace{T}}, W<:(AbstractMappings.Field{Dim})}","page":"Poisson equation","title":"Taiga.PoissonModule.Poisson","text":"Poisson(F::M, S::V, C::ScalarSplineSpaceConstraints{Dim}, uʰ::W, ūʰ::W, κ::Function, f::Function, t::Function; matrixfree=false) where {Dim,T,M<:GeometricMapping{Dim},V<:ScalarFunctionSpace{Dim,T},W<:Field{Dim}}\n\nConstruct Poisson model.\n\nArguments:\n\nF::M: geometric mapping\nS::V: scalar function space\nC::ScalarSplineSpaceConstraints{Dim}: function space constraints\nuʰ::W: scalar solution field\nūʰ::W: scalar solution field satisfying Dirichlet boundary conditions\nκ::Function: conductivity matrix as a function of spatial coordinates \nf::Function: body force as function of spatial coordinates\nt::Function: traction vector as function of spatial coordinates\nmatrixfree::Bool: boolean flag for matrix-free forward problem, default is false\n\n\n\n\n\n","category":"method"},{"location":"poisson/#Taiga.apply_particular_solution-Union{Tuple{V}, Tuple{Poisson, V}} where V<:(AbstractVector)","page":"Poisson equation","title":"Taiga.apply_particular_solution","text":"apply_particular_solution(model::Poisson, x₀::V) where {V<:AbstractVector}\n\nApplies particular solution to homogeneous solution vector.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#Taiga.apply_particular_solution-Union{Tuple{V}, Tuple{Taiga.PoissonModule.LinearOperator, V}} where V<:(AbstractVector)","page":"Poisson equation","title":"Taiga.apply_particular_solution","text":"apply_particular_solution(L::LinearOperator, x₀::V) where {V<:AbstractVector}\n\nApplies particular solution to homogeneous solution vector.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#Taiga.forcing!-Tuple{AbstractVector, Taiga.PoissonModule.LinearOperator}","page":"Poisson equation","title":"Taiga.forcing!","text":"forcing!(b::AbstractVector, L::LinearOperator)\n\nUpdates forcing vector b.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#Taiga.forcing-Tuple{Taiga.PoissonModule.LinearOperator}","page":"Poisson equation","title":"Taiga.forcing","text":"forcing(L::LinearOperator)\n\nReturns forcing vector.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#Taiga.linear_operator-Tuple{Poisson}","page":"Poisson equation","title":"Taiga.linear_operator","text":"linear_operator(model::Poisson; matrixfree::Bool=false, constrained::Bool=true)\n\nReturns a linear operator corresponding for model. Depending on the matrixfree keyword either PoissonModule.LinearOperator or PoissonModule.MatrixfreeLinearOperator is returned. For PoissonModule.MatrixfreeLinearOperator the constrained flag controls if the extraction operator is built into the matrix-free linear operator.\n\n\n\n\n\n","category":"method"},{"location":"poisson/#Taiga.linear_operator_approximation-Tuple{Poisson}","page":"Poisson equation","title":"Taiga.linear_operator_approximation","text":"linear_operator_approximation(model::Poisson; method::Type{<:DataApproximationMethod})\n\nReturns PoissonModule.LinearOperatorApproximation for Poisson model using one of Taiga.DataApproximationMethod.\n\n\n\n\n\n","category":"method"},{"location":"immersed_potentialflow/#ImmersedPotentialFlowModule","page":"Immersed potential flow","title":"ImmersedPotentialFlowModule","text":"This module implements an immersed Galerkin discretization of the Potential flow with (non)homogenous Dirichlet and Neumann boundary conditions.\n\n(Image: Immersed potential flow around rotating cylinder)\n\n./examples/immersed_potentialflow/rotating_cylinder.jl\n\n(Image: Immersed potential flow around torus)\n\n./examples/immersed_potentialflow/torus.jl","category":"section"},{"location":"immersed_potentialflow/#Index","page":"Immersed potential flow","title":"Index","text":"","category":"section"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.ImmersedPotentialFlow","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.ImmersedPotentialFlow","text":"ImmersedPotentialFlow{Dim, T, M <: GeometricMapping{Dim}, V <: ScalarSplineSpace{Dim, T}, W <: Field{Dim}}\n\nImmersed Galerkin formulation of potential flow. The solution field can be either velocity potential or stream function.\n\nFields:\n\nF::M: geometric mapping\nS::V: constrained solution space\nΔ::Partition{Dim, T}: partition\nuʰ::W: solution field\nūʰ::W: function satisfying Dirichlet boundary condition\nt::Function: traction vector\nϕ::AlgoimCallLevelSetFunction: level set function\n\n\n\n\n\n","category":"type"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.LinearOperator","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.LinearOperator","text":"LinearOperator{Dim, T, S <: SparseMatrixCSC{T}, M <: AbstractMatrix{T}, V <: AbstractVector{T}}\n\nLinear operator for ImmersedPotentialFlow model.\n\nFields:\n\nC::S: sparse extraction operator\nE::S: sparse extension operator\nK::M: sparse stiffness matrix\nL::S: sparse linear operator Eᵀ Cᵀ K C E\nb::V: right hand side vector\n\n\n\n\n\n","category":"type"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.Pressure","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.Pressure","text":"Pressure{Dim, T1, T2 <: Velocity{Dim}}\n\nPressure mapping for uniform far field flow.\n\nFields:\n\nρ::T1: density\np::T1: far field pressure\nU::T1: far field velocity magnitude\nvelocity::T2: velocity field\n\n\n\n\n\n","category":"type"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.PrimaryField","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.PrimaryField","text":"abstract type PrimaryField end\n\nPrimary field indicator.\n\n\n\n\n\n","category":"type"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.PullbackBody","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.PullbackBody","text":"PullbackBody{Dim, T <: GeometricMapping{Dim}}\n\nPullback of bilinear form.\n\nFields:\n\nmapping::T: geometric mapping\n\n\n\n\n\n","category":"type"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.PullbackBoundary","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.PullbackBoundary","text":"PullbackBoundary{Dim, T <: GeometricMapping{Dim}}\n\nPullback of linear form.\n\nFields:\n\nmapping::T: geometric mapping\ntraction::Function: traction vector\nside::Int: side restriction (side <= 2Dim)\n\n\n\n\n\n","category":"type"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.StreamFunction","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.StreamFunction","text":"StreamFunction <: PrimaryField\n\nStream function primary field.\n\n\n\n\n\n","category":"type"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.Velocity","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.Velocity","text":"Velocity{Dim, F <: PrimaryField, T1 <: GeometricMapping{Dim}, T2 <: Field{Dim}}\n\nVelocity mapping. Supports potential as velocity potential or stream function.\n\nFields:\n\nmapping::T1: geometric mapping\npotential::T2: potential\n\n\n\n\n\n","category":"type"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.VelocityPotential","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.VelocityPotential","text":"VelocityPotential <: PrimaryField\n\nVelocity potential primary field.\n\n\n\n\n\n","category":"type"},{"location":"immersed_potentialflow/#SparseArrays.sparse-Tuple{Taiga.ImmersedPotentialFlowModule.LinearOperator}","page":"Immersed potential flow","title":"SparseArrays.sparse","text":"SparseArrays.sparse(L::LinearOperator)\n\nGet sparse linear operator.\n\n\n\n\n\n","category":"method"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.assemble_body-Union{Tuple{Dim}, Tuple{IgaFormation.ElementAccessor{Dim}, IgaFormation.ElementAccessor{Dim}, CartesianProducts.CartesianProduct{Dim, Tuple{Vararg{T, Dim}}, Tuple{Vararg{S, Dim}}} where {T, S<:SortedSequences.IncreasingSequence{T}}, Taiga.ImmersedPotentialFlowModule.PullbackBody{Dim, T} where T<:(AbstractMappings.GeometricMapping{Dim}), Algoim.AlgoimCallLevelSetFunction}} where Dim","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.assemble_body","text":"assemble_body(acc::ElementAccessor{Dim}, acc_immersed::ElementAccessor{Dim}, partition::Partition{Dim}, pullback::PullbackBody{Dim}, ϕ::AlgoimCallLevelSetFunction; show_progress::Bool = true)\n\nAssemble unconstrained stiffness matrix.\n\nArguments:\n\nacc: element accessor\nacc_immersed: immersed element accessor\npartition: partition\npullback: bilinear form pullback\nϕ: level set function\nshow_progress: boolean flag for formation progress bar\n\n\n\n\n\n","category":"method"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.assemble_boundary-Union{Tuple{T}, Tuple{M}, Tuple{N}, Tuple{Dim}, Tuple{IgaFormation.ElementAccessor{Dim}, IgaFormation.ElementAccessor{Dim}, CartesianProducts.CartesianProduct{Dim, Tuple{Vararg{T, Dim}}, Tuple{Vararg{S, Dim}}} where S<:SortedSequences.IncreasingSequence{T}, Tuple{Vararg{Taiga.ImmersedPotentialFlowModule.PullbackBoundary{M, T} where T<:(AbstractMappings.GeometricMapping{M}), N}}, Algoim.AlgoimCallLevelSetFunction}} where {Dim, N, M, T}","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.assemble_boundary","text":"assemble_boundary(acc::ElementAccessor{Dim}, acc_immersed::ElementAccessor{Dim}, partition::Partition{Dim, T}, pullbacks_boundary::NTuple{N, PullbackBoundary{M}}, ϕ::AlgoimCallLevelSetFunction)\n\nAssemble right hand side vector.\n\nArguments:\n\nacc: element accessor\nacc_immersed: immersed element accessor\npartition: partition\npullbacks_boundary: tuple of 2Dim linear form pullbacks restricted to each boundary\nϕ: level set function\n\n\n\n\n\n","category":"method"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.embedding-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.embedding","text":"embedding(width::T, height::T, depth::T)\n\nReturn Cartesian background mapping.\n\n\n\n\n\n","category":"method"},{"location":"immersed_potentialflow/#Taiga.ImmersedPotentialFlowModule.embedding-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"Immersed potential flow","title":"Taiga.ImmersedPotentialFlowModule.embedding","text":"embedding(width::T, height::T)\n\nReturn Cartesian background mapping.\n\n\n\n\n\n","category":"method"},{"location":"immersed_potentialflow/#Taiga.apply_particular_solution-Union{Tuple{V}, Tuple{Taiga.ImmersedPotentialFlowModule.LinearOperator, ImmersedPotentialFlow, V}} where V<:(AbstractVector)","page":"Immersed potential flow","title":"Taiga.apply_particular_solution","text":"Taiga.apply_particular_solution(L::LinearOperator, model::ImmersedPotentialFlow, x₀::V)\n\nReturn particular solution.\n\nArguments:\n\nL: linear operator\nmodel: model\nx₀: homogeneous solution\n\n\n\n\n\n","category":"method"},{"location":"immersed_potentialflow/#Taiga.forcing!-Tuple{AbstractVector, Taiga.ImmersedPotentialFlowModule.LinearOperator, ImmersedPotentialFlow}","page":"Immersed potential flow","title":"Taiga.forcing!","text":"Taiga.forcing!(b::AbstractVector, L::LinearOperator, model::ImmersedPotentialFlow)\n\nUpdate forcing vector.\n\nArguments:\n\nb: cache vector\nL: linear operator\nmodel: model\n\n\n\n\n\n","category":"method"},{"location":"immersed_potentialflow/#Taiga.forcing-Tuple{Taiga.ImmersedPotentialFlowModule.LinearOperator, ImmersedPotentialFlow}","page":"Immersed potential flow","title":"Taiga.forcing","text":"Taiga.forcing(L::LinearOperator, model::ImmersedPotentialFlow)\n\nReturn foring vector.\n\n\n\n\n\n","category":"method"},{"location":"immersed_potentialflow/#Taiga.linear_operator-Tuple{ImmersedPotentialFlow}","page":"Immersed potential flow","title":"Taiga.linear_operator","text":"Taiga.linear_operator(model::ImmersedPotentialFlow; show_progress::Bool = true)\n\nConstruct linear operator.\n\n\n\n\n\n","category":"method"},{"location":"potentialflow/#PotentialFlowModule","page":"Potential flow","title":"PotentialFlowModule","text":"This module implements a Galerkin discretization of the potential flow with (non)homogenous Dirichlet and Neumann boundary conditions.\n\n(Image: Potential flow around cylinder)\n\n./examples/immersed_potentialflow/cylinder.jl","category":"section"},{"location":"potentialflow/#Index","page":"Potential flow","title":"Index","text":"","category":"section"},{"location":"potentialflow/#Taiga.FastDiagonalization-Union{Tuple{PotentialFlow{Dim, T, M, V, W} where {M<:(AbstractMappings.GeometricMapping{Dim}), V<:CartesianProducts.TensorProduct{Dim, UnivariateSplines.SplineSpace{T}}, W<:(AbstractMappings.Field{Dim})}}, Tuple{T}, Tuple{Dim}} where {Dim, T}","page":"Potential flow","title":"Taiga.FastDiagonalization","text":"Taiga.FastDiagonalization(model::PotentialFlow{Dim, T}; method::Type{<:DataApproximationMethod} = Wachspress, kwargs)\n\nPotential flow fast diagonalization preconditioner.\n\n\n\n\n\n","category":"method"},{"location":"potentialflow/#Taiga.PotentialFlowModule.LinearOperator","page":"Potential flow","title":"Taiga.PotentialFlowModule.LinearOperator","text":"LinearOperator{Dim, T, B <: KroneckerProduct{T}, M <: AbstractMatrix{T}, V <: AbstractVector{T}}\n\nLinear operator for PotentialFlow model.\n\nFields:\n\nC::B: Kronecker product extraction operator\nK::M: sparse stiffness matrix\nb::V: forcing vector\ncache₁::Vector{T}: mul! cache\ncache₂::Vector{T}: mul! cache\n\n\n\n\n\n","category":"type"},{"location":"potentialflow/#Taiga.PotentialFlowModule.PotentialFlow","page":"Potential flow","title":"Taiga.PotentialFlowModule.PotentialFlow","text":"PotentialFlow{Dim, T, M <: GeometricMapping{Dim}, V <: ScalarSplineSpace{Dim, T}, W <: Field{Dim}}\n\nGalerkin formulation of potential flow. The solution field can be either velocity potential or stream function.\n\nFields:\n\nF::M: geometric mapping\nS::V: constrained solution space\nΔ::Partition{Dim, T}: partition\nuʰ::W: solution field\nūʰ::W: function satisfying Dirichlet boundary conditions\nt::Function: traction vector\n\n\n\n\n\n","category":"type"},{"location":"potentialflow/#Taiga.PotentialFlowModule.Pressure","page":"Potential flow","title":"Taiga.PotentialFlowModule.Pressure","text":"Pressure{Dim, T1, T2 <: Velocity{Dim}}\n\nPressure mapping for uniform far field flow.\n\nFields:\n\nρ::T1: density\np::T1: far field pressure\nU::T1: far field velocity magnitude\nvelocity::T2: velocity field\n\n\n\n\n\n","category":"type"},{"location":"potentialflow/#Taiga.PotentialFlowModule.PullbackBody","page":"Potential flow","title":"Taiga.PotentialFlowModule.PullbackBody","text":"PullbackBody{Dim, T <: GeometricMapping{Dim}}\n\nPullback of bilinear form.\n\nFields:\n\nmapping::T: geometric mapping\n\n\n\n\n\n","category":"type"},{"location":"potentialflow/#Taiga.PotentialFlowModule.PullbackBoundary","page":"Potential flow","title":"Taiga.PotentialFlowModule.PullbackBoundary","text":"PullbackBoundary{Dim, T <: GeometricMapping{Dim}}\n\nPullback of linear form.\n\nFields:\n\nmapping::T: geometric mapping\ntraction::Function: traction vector\nside::Int: side restriction (side <= 2Dim)\n\n\n\n\n\n","category":"type"},{"location":"potentialflow/#Taiga.PotentialFlowModule.Velocity","page":"Potential flow","title":"Taiga.PotentialFlowModule.Velocity","text":"Velocity{Dim, T1 <: GeometricMapping{Dim}, T2 <: Field{Dim}}\n\nVelocity mapping.\n\nFields:\n\nmapping::T1: geometric mapping\npotential::T2: potential field\n\n\n\n\n\n","category":"type"},{"location":"potentialflow/#Taiga.PotentialFlowModule.assemble_body-Union{Tuple{Dim}, Tuple{IgaFormation.ElementAccessor{Dim}, CartesianProducts.CartesianProduct{Dim, Tuple{Vararg{T, Dim}}, Tuple{Vararg{S, Dim}}} where {T, S<:SortedSequences.IncreasingSequence{T}}, Taiga.PotentialFlowModule.PullbackBody{Dim, T} where T<:(AbstractMappings.GeometricMapping{Dim})}} where Dim","page":"Potential flow","title":"Taiga.PotentialFlowModule.assemble_body","text":"assemble_body(acc::ElementAccessor{Dim}, partition::Partition{Dim}, pullback::PullbackBody{Dim})\n\nAssemble unconstrained stiffness matrix.\n\nArguments:\n\nacc: element accessor\npartition: partition\npullback: bilinear form pullback\n\n\n\n\n\n","category":"method"},{"location":"potentialflow/#Taiga.PotentialFlowModule.assemble_boundary-Union{Tuple{T}, Tuple{M}, Tuple{N}, Tuple{Dim}, Tuple{IgaFormation.ElementAccessor{Dim}, CartesianProducts.CartesianProduct{Dim, Tuple{Vararg{T, Dim}}, Tuple{Vararg{S, Dim}}} where S<:SortedSequences.IncreasingSequence{T}, Tuple{Vararg{Taiga.PotentialFlowModule.PullbackBoundary{M, T} where T<:(AbstractMappings.GeometricMapping{M}), N}}}} where {Dim, N, M, T}","page":"Potential flow","title":"Taiga.PotentialFlowModule.assemble_boundary","text":"assemble_boundary(acc::ElementAccessor{Dim}, partition::Partition{Dim, T}, pullbacks_boundary::NTuple{N, PullbackBoundary{M}})\n\nAssemble right hand side vector.\n\nArguments:\n\nacc: element accessor\npartition: partition\npullbacks_boundary: tuple of 2Dim linear form pullbacks restricted to each boundary\n\n\n\n\n\n","category":"method"},{"location":"potentialflow/#Taiga.apply_particular_solution-Union{Tuple{V}, Tuple{Taiga.PotentialFlowModule.LinearOperator, PotentialFlow, V}} where V<:(AbstractVector)","page":"Potential flow","title":"Taiga.apply_particular_solution","text":"Taiga.apply_particular_solution(L::LinearOperator, model::PotentialFlow, x₀::V)\n\nReturn particular solution.\n\nArguments:\n\nL: linear operator\nmodel: model\nx₀: homogeneous solution\n\n\n\n\n\n","category":"method"},{"location":"potentialflow/#Taiga.forcing!-Tuple{AbstractVector, Taiga.PotentialFlowModule.LinearOperator, PotentialFlow}","page":"Potential flow","title":"Taiga.forcing!","text":"Taiga.forcing!(b::AbstractVector, L::LinearOperator, model::PotentialFlow)\n\nUpdate forcing vector.\n\nArguments:\n\nb: cache vector\nL: linear operator\nmodel: model\n\n\n\n\n\n","category":"method"},{"location":"potentialflow/#Taiga.forcing-Tuple{Taiga.PotentialFlowModule.LinearOperator, PotentialFlow}","page":"Potential flow","title":"Taiga.forcing","text":"Taiga.forcing(L::LinearOperator, model::PotentialFlow)\n\nReturn forcing vector.\n\n\n\n\n\n","category":"method"},{"location":"potentialflow/#Taiga.linear_operator-Tuple{PotentialFlow}","page":"Potential flow","title":"Taiga.linear_operator","text":"Taiga.linear_operator(model::PotentialFlow)\n\nConstruct linear operator.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.jl","page":"Home","title":"Taiga.jl","text":"Tensor-product applications in isogeometric analysis.\n\nnote: Note\nExamples listed on this page use following packagesusing Taiga\nusing LinearAlgebra\nusing SortedSequences, CartesianProducts, KroneckerProducts, NURBS, SpecialSpaces, AbstractMappings, UnivariateSplines","category":"section"},{"location":"#Postprocessing","page":"Home","title":"Postprocessing","text":"Some basic postprocessing methods are provided as Plots recipes in most packages in the Feather ecosystem. Taiga.jl implements Bézier extraction and can save mappings, fields and control nets to a VTK file, e.g\n\nmapping = hole_in_square_plate()\nmapping = refine(mapping, method=hRefinement(3))\nspace = ScalarSplineSpace(mapping.space)\n\neuclidean_distance = Field((x,y) -> sqrt(x^2 + y^2))\nd = Field(space)\nproject!(d, onto=euclidean_distance ∘ mapping; method=QuasiInterpolation)\n\nvtk_save_bezier(\"geometry_and_field\", mapping; fields = Dict(\"d\" => d))\nvtk_save_control_net(\"control_net\", mapping)\n\n(Image: Bezier extraction on square plate with a hole)\n\nMore detailed examples are provided in the examples directory.","category":"section"},{"location":"#Aggregation-of-Kronecker-products","page":"Home","title":"Aggregation of Kronecker products","text":"More often then not Kronecker product approximations will be composed of a sum of Kronecker products. In most cases these sums will not have the classical Kronecker sum structure. Nonetheless, it is still possible to evaluate matrix-vector products with these operators with complexity mathcal O(Mcdot N^32) and  mathcal O(Mcdot N^43) in 2 and 3 dimensions, where M is the number of Kronecker products in the collection.\n\nKroneckerProductAggregate is a collection of Kronecker product matrices of conforming size that acts as a linear map and supports reduction over the collection, e.g.\n\njulia> A = rand(7, 3) ⊗ rand(5, 3) ⊗ rand(3, 5);\n\njulia> B = rand(7, 3) ⊗ rand(5, 3) ⊗ rand(3, 5);\n\njulia> C = A + B;\n\njulia> K = KroneckerProductAggregate(A, B);\n\njulia> v = rand(size(C, 2));\n\njulia> b = K * v;\n\njulia> b ≈ C * v\ntrue\n\njulia> mul!(b, K, v); # in-place evaluation\n\njulia> b ≈ C * v\ntrue\n\nA KroneckerProductAggregate supports LinearAlgebra.mul!, LinearAlgebra.adjoint, Base.isempty, Base.push! and most other  methods that abstract matrices implement.","category":"section"},{"location":"#KroneckerFactory","page":"Home","title":"KroneckerFactory","text":"Let us consider that we need to assemble the bilinear form associated with the operator L(u) = ∇ ⋅ (C∇u) where C = [6.0 0.1875; 0.125 12.0] is a conductivity matrix. Clearly, even on Cartesian grids an exact FastDiagonalization of the resulting matrix is not possible due to non-zero off-diagonal entries in C. Furthermore, if C is a function of the spatial coordinates, the resulting stiffness matrix does not have a Kronecker product structure at all and the material pullback needs to be approximated using some separable approximation.\n\nKroneckerFactory can be used to obtain approximations of a bilinear form given a separable approximation of the data, i.e. weighted spline approximation of the pullback operator on mapped geometries or Wachspress approximation at quadrature points.\n\nThe syntax is close to that of IgaFormation.Sumfactory.\n\n# domain\nΩ = Interval(0.0, 1.0) ⨱ Interval(0.0, 1.0)\n\n# partition\nΔ = Partition(Ω, (3,5))\n\n# space\np = (2,3)\nS = ScalarSplineSpace(p, Δ)\n\n# mock data\nDim = length(S)\nnqpts = map((p,n) -> (p+1)*n + 2, p, num_elements.(S))\nf = [ map(rand, nqpts) for k ∈ 1:Dim, l ∈ 1:Dim]\n\n# derivative indicators\n∇u = k -> ι(k, dim=Dim)\n∇v = k -> ι(k, dim=Dim)\n\n# assemble stiffness\n∫ = KroneckerFactory(S, S)\nfor β in 1:Dim\n    for α in 1:Dim\n        ∫(∇u(α), ∇v(β); data=f[α, β])\n    end\nend\n\n# aggregated Kronecker products\nK = ∫.data\n\nIn the above, f[α, β] is a Tuple of either univariate weighting splines in each parametric direction or plain vectors with weighting coefficients. This data is used to weight the test functions. \n\nSimilarly to Sumfactory, the data collection can be reset\n\n∫(∇u(α), ∇v(β); data=f[α, β], reset=true)\n\nor simply\n\nreset!(∫)","category":"section"},{"location":"#Linear-solvers","page":"Home","title":"Linear solvers","text":"Taiga provides minimal reference implementations of linear solvers:\n\nTaigaCG Conjugate Gradient method\nTaigaPCG preconditioned Conjugate Gradient method\nTaigaIPCG inexactly preconditioned Conjugate Gradient method\n\nThese implementations are reasonably fast. The solution times are at least as good as Krylov.jl, whereby due to the minimal implementation there are less memory allocations. Furthermore, some solvers like TaigaIPCG are nowhere to be found and are essential to Taiga's conceptual framework.\n\njulia> solver = TaigaPCG(L, P; atol=10e-8, rtol=10e-8, itmax=100)\nLinear solver of type TaigaPCG (atol=1.0e-7, rtol=1.0e-7, itmax=100)\n\njulia> x, stats = linsolve!(solver, b);\n\njulia> stats\nLinear solver statistics for TaigaPCG:\n┌──────────────────┬───────────────────────────────┐\n│ Metric           │ Value                         │\n├──────────────────┼───────────────────────────────┤\n│ converged        │ true                          │\n│ niter            │ 47                            │\n│ residual_norm    │ 9.25797e-8                    │\n│ residual_norm_x₀ │ 0.0732086                     │\n│ status           │ coverged: atol ✔, rtol ✘      │\n└──────────────────┴───────────────────────────────┘","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#Taiga.BezierExtractionContext","page":"Home","title":"Taiga.BezierExtractionContext","text":"BezierExtractionContext{Dim, T}\n\nBezier extraction context.\n\nFields:\n\nsplinespace::TensorProduct{Dim, SplineSpace{T}}: spline space\npartition::CartesianProduct{Dim}: partition\nC::Array{KroneckerProduct, Dim}: Bezier extraction operators\nbezier_basis_dimension::NTuple{Dim}: Bezier basis dimension\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.BezierExtractionContext-Union{Tuple{UnivariateSplines.SplineSpace{T}}, Tuple{T}} where T","page":"Home","title":"Taiga.BezierExtractionContext","text":"BezierExtractionContext(S::SplineSpace{T})\n\nConstruct BezierExtractionContext from a univariate spline space.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.CanonicalPolyadic","page":"Home","title":"Taiga.CanonicalPolyadic","text":"CanonicalPolyadic <: DataApproximationMethod\n\nMethod to approximate patch data as separable functions using Canonical polyadic decomposition.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.Constrained","page":"Home","title":"Taiga.Constrained","text":"Constrained{x}\n\nCan be used as a constrained/unconstrained flag. Similar to Val but takes only booleans as x.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.DataApproximationMethod","page":"Home","title":"Taiga.DataApproximationMethod","text":"abstract type DataApproximationMethod\n\nConcrete data approximatino methods derive from this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.FastDiagonalization","page":"Home","title":"Taiga.FastDiagonalization","text":"FastDiagonalization{Dim,T,K<:KroneckerProduct{T}}\n\nFast diagonalization preconditioner.\n\nFields:\n\nΛ⁻¹::Diagonal{T, Vector{T}}: diagonal matrix of reciprocal of positive eigenvalues\nU::K: Kronecker product eigenvectors\nsize::NTuple{2, Int}: operator size\ncache::Vector{T}: intermediate product cache\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.HyperPowerPreconditioner","page":"Home","title":"Taiga.HyperPowerPreconditioner","text":"HyperPowerPreconditioner{Dim, T, A <: LinearOperatorApproximation{Dim, T}, B <: Preconditioner{Dim, T}}\n\nPreconditioner based on the Ben-Israel-Cohen iteration.\n\nPₖ₊₁⁻¹ = 2 Pₖ⁻¹ - Pₖ⁻¹ A Pₖ⁻¹     (Pₖ⁻¹ → A⁻¹   for   k → ∞)\n\nRequires a linear operator A and an initial preconditioner P. Computes one update of the Ben-Israel-Cohen iteration. Convergence to A⁻¹ and positive definiteness are guaranteed as long as σ(P⁻¹A) ⊂ (0,2).\n\nFor recursive application, i.e. n iterations, use the convenience constructor\n\nHyperPowerPreconditioner(L::A, P::B, n::Int) where {Dim,T,A<:LinearOperatorApproximation{Dim,T},B<:Preconditioner{Dim,T}}\n\nwhere P is the initial preconditioner and n is the number of updates.\n\nFields:\n\nA::A: linear operator of which the inverse is approximated\nP::B: initial preconditioner\nv₁::Vector{T}: vector cache\nv₂::Vector{T}: vector cache\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.InnerCG","page":"Home","title":"Taiga.InnerCG","text":"InnerCG{Dim, T, L <: LinearOperatorApproximation} <: Preconditioner{Dim,T}\n\nPreconditioner using inner CG solver. In applications the linear operator approximation A can be cheaply applied to a vector. The parameter η ∈ [0,1) controls the tolerance of the inner solve. Decreasing η increases the number of inner iterations.\n\nThe history can be reset using reset_inner_solver_history!.\n\nFields:\n\nA::L: approximation of a linear operator to be preconditioned\np::Vector{T}: cache vector\nAp::Vector{T}: cache vector\nr::Vector{T}: cache vector\nη::T: factor for convergence criterion (η ∈ [0,1))\nη̂::T: factor for convergence criterion respective cond(A)\nitmax::Int: maximum number of inner iterations\nconvergence::Vector{Bool}: vector with history of convergence\nresiduals::Vector{T}: vector with history of residuals\nniters::Vector{Int}: vector with history of number of iterations\nhistory::Bool: boolean flag for history keeping\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.InnerCG-Union{Tuple{L}, Tuple{T}, Tuple{Dim}} where {Dim, T, L<:LinearOperatorApproximation{Dim, T}}","page":"Home","title":"Taiga.InnerCG","text":"InnerCG(A::L; history=false, itmax::Int=200, η::T=10e-5, eigtol::T=10e-2) where {Dim,T,L<:LinearOperatorApproximation{Dim,T}}\n\nConstruct InnerCG preconditioner. The positive definiteness is checked by extreme_eigenvalues. The eigtol keyword controls the tolerance for the extreme eigenvalues computation.\n\nArguments:\n\nA::L: approximatino of a linear operator to be preconditioned\nhistory::Bool: boolean flag for history keeping\nη::T: factor for convergence criterion (η ∈ [0,1))\nskip_checks::Bool: boolean flag for skipping posdef checks (default: false)\nitmax::Int: maximum number of inner iterations\neigtol::T: tolerance for extreme_eigenvalues](@ref) computation\neigrestarts::Int: number of restarts for extreme_eigenvalues](@ref) computation\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.InnerPCG","page":"Home","title":"Taiga.InnerPCG","text":"InnerPCG{Dim, T, L <: LinearOperatorApproximation{Dim, T}, P <: Preconditioner{Dim, T}}\n\nPreconditioner using inner PCG solver. In applications the linear operator approximation A can be cheaply applied to a vector. The preconditioner P preconditions the inner solve. The parameter η ∈ [0,1) controls the tolerance of the inner solve. Decreasing η increases the number of inner iterations.\n\nThe history can be reset using reset_inner_solver_history!.\n\nFields:\n\nA::L: approximation of a linear operator to be preconditioned\nM::P: preconditioner for the inner solve\np::Vector{T}: cache vector\nAp::Vector{T}: cache vector\nr::Vector{T}: cache vector\nz::Vector{T}: cache vector\nη::T: factor for convergence criterion (η ∈ [0,1))\nη̂::T: factor for convergence criterion respective cond(A)\nitmax::Int: maximum number of inner iterations\nconvergence::Vector{Bool}: vector with history of convergence\nresiduals::Vector{T}: vector with history of residuals\nniters::Vector{Int}: vector with history of number of iterations\nhistory::Bool: boolean flag for history keeping\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.InnerPCG-Union{Tuple{P}, Tuple{L}, Tuple{T}, Tuple{Dim}, Tuple{L, P}} where {Dim, T, L<:LinearOperatorApproximation{Dim, T}, P<:Preconditioner{Dim, T}}","page":"Home","title":"Taiga.InnerPCG","text":"InnerPCG(A::L, P; history=false, itmax::Int=200, η::T=10e-5, eigtol::T=10e-2) where {Dim,T,L<:LinearOperatorApproximation{Dim,T}}\n\nConstruct InnerCG preconditioner. The positive definiteness is checked by extreme_eigenvalues. The eigtol keyword controls the tolerance for the extreme eigenvalues computation.\n\nArguments:\n\nA::L: approximatino of a linear operator to be preconditioned\nhistory::Bool: boolean flag for history keeping\nη::T: factor for convergence criterion (η ∈ [0,1))\nskip_checks::Bool: boolean flag for skipping posdef checks (default: false)\nitmax::Int: maximum number of inner iterations\neigtol::T: tolerance for extreme_eigenvalues](@ref) computation\neigrestarts::Int: number of restarts for extreme_eigenvalues](@ref) computation\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.KroneckerFactory","page":"Home","title":"Taiga.KroneckerFactory","text":"KroneckerFactory{Dim, T, S <: SplineSpace{T}, K <: KroneckerProductAggregate{T}}\n\nA factory that assembles Kronecker product system matrices. Acts as a functor accepting optional weighting for test functions and collects Kronecker product matrix contributions in a KroneckerProductAggregate.\n\nFields:\n\ntrialspace::TensorProduct{Dim, S}: trial functions space\ntestspace::TensorProduct{Dim, S}: test functions space\ndata::K: Kronecker product contributions\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.KroneckerFactory-Union{Tuple{S}, Tuple{T}, Tuple{Dim}, Tuple{CartesianProducts.TensorProduct{Dim, S}, CartesianProducts.TensorProduct{Dim, S}}} where {Dim, T, S<:UnivariateSplines.SplineSpace{T}}","page":"Home","title":"Taiga.KroneckerFactory","text":"KroneckerFactory(trialspace::TensorProduct{Dim, S}, testspace::TensorProduct{Dim, S}) where {Dim,T,S<:SplineSpace{T}}\n\nConstructs KroneckerFactory.\n\nArguments:\n\ntrialspace: trial functions space\ntestspace: test functions space\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.KroneckerFactory-Union{Tuple{T}, Tuple{N}, Tuple{Dim}, Tuple{Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where {Dim, N, T<:Real}","page":"Home","title":"Taiga.KroneckerFactory","text":"f::KroneckerFactory{Dim}(v::NTuple{N, Int}, w::NTuple{N, Int}; data = nothing, reset::Bool=false)\n\nAssembles Kronecker product system matrices with test functions weighted by data (optional). The Kronecker product contributions are collected in the f.data which is a  KroneckerProductAggregate.\n\nFor applicable data see weighted_system_matrix.\n\nArguments:\n\nv: tuple indicating trial function derivatives, see ι\nw: tuple indicating test function derivatives, see ι\ndata: optional weighting of test functions\nreset: optional flag to reset the collection f.data\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.KroneckerProductAggregate","page":"Home","title":"Taiga.KroneckerProductAggregate","text":"KroneckerProductAggregate{T,S<:KroneckerProduct{T}} <: LinearMap{T}\n\nA collection of Kronecker product matrices that acts as a  linear operator represented by a sum over that collection.\n\nFields:\n\nK::Vector{KroneckerProduct}: collection of Kronecker products\nsize::Tuple{Int,Int}: size of the operator\ncache::Vector{T}: matrix-vector product cache\nisposdef::Bool: operator is positive definite flag\nishermitian::Bool: operator is hermitian flag\nissymmetric::Bool: operator is symmetric flag\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.KroneckerProductAggregate-Union{Tuple{Int64, Int64}, Tuple{T}} where T","page":"Home","title":"Taiga.KroneckerProductAggregate","text":"KroneckerProductAggregate{T}(m::Int, n::Int; isposdef::Bool=false, ishermitian::Bool=false, issymmetric::Bool=false) where {T}\n\nConstructs an empty KroneckerProductAggregate of size m × n and properties defined by boolean keywords.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.KroneckerProductAggregate-Union{Tuple{Vararg{S, N}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S<:(KroneckerProducts.KroneckerProduct{T})}","page":"Home","title":"Taiga.KroneckerProductAggregate","text":"KroneckerProductAggregate{T}(m::Int, n::Int; isposdef::Bool=false, ishermitian::Bool=false, issymmetric::Bool=false) where {T}\n\nConstructs a KroneckerProductAggregate based on an arbitrary number of Kronecker products with equal size. Aggregate properties are defined by boolean keywords.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.LinearOperator","page":"Home","title":"Taiga.LinearOperator","text":"abstract type LinearOperator{Dim,T}\n\nConcrete linear operators derive from this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.LinearOperatorApproximation","page":"Home","title":"Taiga.LinearOperatorApproximation","text":"abstract type LinearOperatorApproximation{Dim,T}\n\nConcrete linear operator approximations derive from this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.LinearSolver","page":"Home","title":"Taiga.LinearSolver","text":"abstract type LinearSolver{T} end\n\nConcrete linear solvers derive from this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.LinearSolverStatistics","page":"Home","title":"Taiga.LinearSolverStatistics","text":"LinearSolverStatistics{S <: LinearSolver}\n\nA container for solver statistics. Contains a dictionary data. Keys in data are used to mimic actual fields in this container, see Base.propertynames. Each property can be accessed using Base.setproperty! and Base.getproperty, or stats.propname. The dictonary itself is not accessable via A.data!\n\nFields:\n\ndata::Dict{Symbol, Any}: dictionary containing statistics\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.LinearSolverStatistics-Union{Tuple{Type{S}}, Tuple{S}} where S<:LinearSolver","page":"Home","title":"Taiga.LinearSolverStatistics","text":"LinearSolverStatistics(::Type{S}) where {S<:LinearSolver}\n\nDefault LinearSolverStatistics constructor for one of LinearSolver types.\n\nFollowing statistics are defined by default:\n\n:converged \n:status\n:residual\n:residual_norm_x₀\n:niter\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.ModalSplines","page":"Home","title":"Taiga.ModalSplines","text":"ModalSplines <: DataApproximationMethod\n\nMethod to approximate patch data as separable functions using (ho)svd method and spline interpolation.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.Model","page":"Home","title":"Taiga.Model","text":"abstract type Model\n\nConcrete models derive from this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.NonnegativeCanonicalPolyadic","page":"Home","title":"Taiga.NonnegativeCanonicalPolyadic","text":"NonnegativeCanonicalPolyadic <: DataApproximationMethod\n\nMethod to approximate patch data in R₊ as positive separable functions using the non-negative Canonical polyadic decomposition.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.Preconditioner","page":"Home","title":"Taiga.Preconditioner","text":"abstract type Preconditioner{Dim,T}\n\nConcrete preconditioners derive from this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.TaigaCG","page":"Home","title":"Taiga.TaigaCG","text":"TaigaCG{T, L}\n\nLinear solver implementing the Conjugate Gradient method.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.TaigaIPCG","page":"Home","title":"Taiga.TaigaIPCG","text":"TaigaIPCG{T, L, P}\n\nLinear solver implementing the inexactly preconditioned Conjugate Gradient method.\n\nReferences\n\nGene H. Golub and Qiang Ye. Inexact preconditioned conjugate gradient method with inner-outer iteration. SIAM J. Sci. Comput., 21(4):1305–1320, December 1999.\nAndrew V Knyazev and Ilya Lashuk. Steepest descent and conjugate gradient methods with variable preconditioning. SIAM Journal on Matrix Analysis and Applications, 29(4):1267–1280, 2008.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.TaigaPCG","page":"Home","title":"Taiga.TaigaPCG","text":"TaigaPCG{T, L, P}\n\nLinear solver implementing the preconditioned Conjugate Gradient method.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.TargetSpace","page":"Home","title":"Taiga.TargetSpace","text":"const TargetSpace{T} = UnivariateSplines.SplineSpace{T}\n\nAlias for UnivariateSplines.SplineSpace.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.TestSpace","page":"Home","title":"Taiga.TestSpace","text":"const TestSpace{T} = UnivariateSplines.SplineSpace{T}\n\nAlias for UnivariateSplines.SplineSpace.\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.VTKHigherOrderDegrees","page":"Home","title":"Taiga.VTKHigherOrderDegrees","text":"VTKHigherOrderDegrees{Dim, T}\n\nAn immutable sparse container for WriteVTK higher order degrees array.\n\nThis container acts like an array of size (3, ncells) with repeated columns and supports indexing and views.\n\nFields:\n\ndegrees::NTuple{Dim, T}: cell degrees\nncells::Int: number of Bezier cells\n\n\n\n\n\n","category":"type"},{"location":"#Taiga.Wachspress","page":"Home","title":"Taiga.Wachspress","text":"ModalSpline <: DataApproximationMethod\n\nMethod to approximate patch data at quadrature points using Wachspress algorithms. Works only for data arrays with positive entries.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:*-Union{Tuple{S}, Tuple{T}, Tuple{KroneckerProductAggregate{T, S} where S<:(KroneckerProducts.KroneckerProduct{T}), S}} where {T, S<:(AbstractVector)}","page":"Home","title":"Base.:*","text":"*(K::KroneckerProductAggregate, v::S)\n\nCompute K.K[1] * v + K.K[2] * v + ... + K.K[end] * v.\n\nArguments:\n\nK: collection of Kronecker products\nv: vector to multiply with\n\n\n\n\n\n","category":"method"},{"location":"#Base.adjoint-Tuple{KroneckerProductAggregate}","page":"Home","title":"Base.adjoint","text":"LinearAlgebra.adjoint(K::KroneckerProductAggregate)\n\nReturns an adjoint KroneckerProductAggregate.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getproperty-Tuple{LinearSolverStatistics, Symbol}","page":"Home","title":"Base.getproperty","text":"Base.getproperty(A::LinearSolverStatistics, field::Symbol)\n\nReturns field in A (actually the value associated with key field in A.data).\n\n\n\n\n\n","category":"method"},{"location":"#Base.propertynames-Tuple{LinearSolverStatistics}","page":"Home","title":"Base.propertynames","text":"Base.propertynames(A::LinearSolverStatistics)\n\nReturns all property names of A (keys in A.data!). \n\n\n\n\n\n","category":"method"},{"location":"#Base.push!-Union{Tuple{S}, Tuple{T}, Tuple{KroneckerProductAggregate{T, S} where S<:(KroneckerProducts.KroneckerProduct{T}), S}} where {T, S<:(KroneckerProducts.KroneckerProduct{T})}","page":"Home","title":"Base.push!","text":"Base.push!(K::KroneckerProductAggregate{T}, k::S) where {T,S<:KroneckerProduct{T}}\n\nAdds a Kronecker product matrix to the collection of Kronecker products in K.\n\n\n\n\n\n","category":"method"},{"location":"#Base.setproperty!-Tuple{LinearSolverStatistics, Symbol, Any}","page":"Home","title":"Base.setproperty!","text":"Base.setproperty!(A::LinearSolverStatistics, field::Symbol, value)\n\nSets field in A (actually A.data[field]) to value.\n\nArguments:\n\nA: statistics container\nfield: field to set (a key in data)\nvalue: value to set\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.isposdef-Union{Tuple{H}, Tuple{T}, Tuple{Dim}} where {Dim, T, H<:(HyperPowerPreconditioner{Dim, T, A, B} where {A<:LinearOperatorApproximation{Dim, T}, B<:Preconditioner{Dim, T}})}","page":"Home","title":"LinearAlgebra.isposdef","text":"LinearAlgebra.isposdef(P::H)\n\nReturns true if σ(inv(P₀)A) ⊂ (0,2) and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.opnorm-Union{Tuple{K}, Tuple{T}, Tuple{Dim}} where {Dim, T<:Real, K<:(KroneckerProducts.KroneckerProduct{T, 2, Dim})}","page":"Home","title":"LinearAlgebra.opnorm","text":"LinearAlgebra.opnorm(A::K) where {Dim,T<:Real,K<:KroneckerProduct{T,2,Dim}}\n\nReturns the operator norm ‖A‖₂ of a Kronecker product using Kronecker product eigenvalue decomposition of AᵀA which is fast.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.apply_particular_solution","page":"Home","title":"Taiga.apply_particular_solution","text":"apply_particular_solution\n\nEach model module implements its own method for apply_particular_solution, which adds particular solution to homogeneous solution.\n\n\n\n\n\n","category":"function"},{"location":"#Taiga.approximate_patch_data","page":"Home","title":"Taiga.approximate_patch_data","text":"approximate_patch_data\n\nMethods implementing patch data approximation algorithms.\n\n\n\n\n\n","category":"function"},{"location":"#Taiga.approximate_patch_data-Union{Tuple{E}, Tuple{S2}, Tuple{S1}, Tuple{E, Vararg{Any}}} where {S1, S2, E<:(AbstractMappings.EvaluationSet{S1, S2})}","page":"Home","title":"Taiga.approximate_patch_data","text":"approximate_patch_data(C::E, args; method::Type{<:DataApproximationMethod}, kwargs) where {S1,S2,E<:EvaluationSet{S1,S2}}\n\nApproximate patch data using method. Calls implementation of approximation_patch_data for method with positional arguments args and keyword arguments kwargs.\n\nArguments:\n\nC: patch data as IgaFormation.EvaluationSet\nargs: positional arguments to method\nmethod: approximation method\nkwargs: keyword arguments to method\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.approximate_patch_data-Union{Tuple{E}, Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Type{<:CanonicalPolyadic}, E}} where {T, S1, S2, E<:(AbstractMappings.EvaluationSet{S1, S2})}","page":"Home","title":"Taiga.approximate_patch_data","text":"approximate_patch_data(::Type{<:CanonicalPolyadic}, C::E; tol::T=10e-1, rank::Int=1, ntries::Int=10) where {Dim,S1,S2,E<:EvaluationSet{S1,S2},T}\n\nReturns an array of size rank × S1 × S2 of Vector tuples of length Dim for each data array in C.\n\nArguments:\n\nC: patch data as IgaFormation.EvaluationSet\ntol: cp tolerance\nrank: number of cp modes\nntries: number of attempts to compute the CP decomposition per block\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.approximate_patch_data-Union{Tuple{T}, Tuple{E}, Tuple{S2}, Tuple{S1}, Tuple{Dim}, Tuple{Type{<:ModalSplines}, E}} where {Dim, S1, S2, E<:(AbstractMappings.EvaluationSet{S1, S2}), T}","page":"Home","title":"Taiga.approximate_patch_data","text":"approximate_patch_data(::Type{<:ModalSplines}, C::E; S::NTuple{Dim,SplineSpace{T}}, rank::Int=1) where {Dim,S1,S2,E<:EvaluationSet{S1,S2},T}\n\nReturns an array of size rank × S1 × S2 of Bspline tuples of length Dim for each data array in C.\n\nArguments:\n\nC: patch data as IgaFormation.EvaluationSet\nspaces: tuple of univariate interpolation spline spaces\nrank: approximation rank\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.bezier_basis_dimension-Union{Tuple{CartesianProducts.TensorProduct{Dim, UnivariateSplines.SplineSpace{T}}}, Tuple{T}, Tuple{Dim}} where {Dim, T}","page":"Home","title":"Taiga.bezier_basis_dimension","text":"bezier_basis_dimension(S::TensorProduct{Dim, SplineSpace{T}})\n\nReturns Bezier basis dimension if extracted from S.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.droptol!-Union{Tuple{S}, Tuple{T}} where {T, S<:(KroneckerProductAggregate{T, S} where S<:(KroneckerProducts.KroneckerProduct{T}))}","page":"Home","title":"Taiga.droptol!","text":"droptol!(K::S; rtol = √(eps(T)))\n\nDrop contributions in K = {K₁, K₂, ...} for which the relative operator norm ‖Kₖ‖₂ / || ‖Kₘₐₓ‖₂ is less then rtol, where for Kₖ ∈ K we find Kₘₐₓ = argmax ‖Kₖ‖₂.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.extreme_eigenvalues-Union{Tuple{L}, Tuple{T}} where {T, L<:LinearMaps.LinearMap}","page":"Home","title":"Taiga.extreme_eigenvalues","text":"extreme_eigenvalues(A::L; tol::T = 0.1, restarts::Int=200) where {T,L<:LinearMap}\n\nCompute extreme eigenvalues of a linear map A. Uses ArnoldiMethod. The tolerance tol can be helpful if ArnoldiMethod converges to more then one maximum or minimum eigenvalue. Checks for complex eigenvalues are performed.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.forcing","page":"Home","title":"Taiga.forcing","text":"forcing\n\nEach model module implements its own method for forcing, which returns the right hand side vector.\n\n\n\n\n\n","category":"function"},{"location":"#Taiga.forcing!","page":"Home","title":"Taiga.forcing!","text":"forcing!\n\nEach model module implements its own method for forcing!, which updates the right hand side vector.\n\n\n\n\n\n","category":"function"},{"location":"#Taiga.get_bezier_basis_indices-Tuple{UnivariateSplines.SplineSpace, Integer}","page":"Home","title":"Taiga.get_bezier_basis_indices","text":"get_bezier_basis_indices(S::SplineSpace, e::Integer)\n\nComputes univariate basis indices of a Bezier basis corresponding to Bspline space S.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.get_system_matrix_quadrule-Tuple{UnivariateSplines.SplineSpace{T} where T, UnivariateSplines.SplineSpace{T} where T}","page":"Home","title":"Taiga.get_system_matrix_quadrule","text":"get_system_matrix_quadrule(S::TargetSpace, V::TestSpace)\n\nReturns a univariate PatchRule for a pair of spaces.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.hyperpower_eigenvalues_after_n_iterations-Tuple{T} where T","page":"Home","title":"Taiga.hyperpower_eigenvalues_after_n_iterations","text":"hyperpower_eigenvalues_after_n_iterations(λ::T; n::Int)\n\nFor a set of eigenvalues λ return the corresponding eigenvalues after n further updates of the Ben-Israel-Cohen iteration.\n\nTransformation rule applies for λ after first update. The upper bound for λ after first update is 1.\n\nExample:\n\njulia> λ₀ = hyperpower_extreme_eigenvalues(P; n=0, tol=10e-5)\n(0.023145184193109333, 1.9749588237991926)\n\njulia> λ₁ = hyperpower_extreme_eigenvalues(P; n=1, tol=10e-5)\n(0.045754651575638426, 0.9999899575917253)\n\njulia> hyperpower_extreme_eigenvalues(P; n=5, tol=10e-5)\n(0.5273271247385951, 0.9999962548752878)\n\njulia> hyperpower_eigenvalues_after_n_iterations(λ₁; n=4)\n(0.5273268941262143, 1.0)\n\njulia> hyperpower_eigenvalues_after_n_iterations(λ₀; n=1)\n(0.0457546604483684, 0.049592390484542115)\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.hyperpower_extreme_eigenvalues-Union{Tuple{H}, Tuple{T}, Tuple{Dim}} where {Dim, T, H<:(HyperPowerPreconditioner{Dim, T, A, B} where {A<:LinearOperatorApproximation{Dim, T}, B<:Preconditioner{Dim, T}})}","page":"Home","title":"Taiga.hyperpower_extreme_eigenvalues","text":"hyperpower_extreme_eigenvalues(P::H; n::Int=1, tol::T=√eps(T)) where {Dim,T,H<:HyperPowerPreconditioner{Dim,T}}\n\nCompute the extreme eigenvalues of inv(Pₙ)A, i.e. return a tuple (λmin, λmax) in nth iteration.\n\nIn the case of eigenvalue clustering, i.e. around the value of 1, it might be necessary to choose lower tol.\n\nExample:\n\njulia\njulia> λ₀ = hyperpower_extreme_eigenvalues(P; n=0, tol=10e-5)\n(0.023145184193109333, 1.9749588237991926)\n\njulia> λ₁ = hyperpower_extreme_eigenvalues(P; n=1, tol=10e-5)\n(0.045754651575638426, 0.9999899575917253)\n\njulia> hyperpower_extreme_eigenvalues(P; n=2, tol=10e-5)\n(0.08941582990237358, 0.9999916150622586)\n\njulia> hyperpower_extreme_eigenvalues(P; n=3, tol=10e-5)\n(0.1708364549356042, 1.0000016638364837)\n\njulia> hyperpower_extreme_eigenvalues(P; n=4, tol=10e-5)\n(0.3124877477755778, 0.9999984021406245)\n\njulia> hyperpower_extreme_eigenvalues(P; n=5, tol=10e-5)\n(0.5273271247385951, 0.9999962548752878)\n\njulia> hyperpower_eigenvalues_after_n_iterations(λ₁; n=2)\n(0.17083641016503434, 1.0)\n\njulia> hyperpower_eigenvalues_after_n_iterations(λ₁; n=3)\n(0.31248774129199286, 1.0)\n\njulia> hyperpower_eigenvalues_after_n_iterations(λ₁; n=4)\n(0.5273268941262143, 1.0)\n\njulia> hyperpower_eigenvalues_after_n_iterations(λ₀; n=1)\n(0.0457546604483684, 0.049592390484542115)\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.hyperpower_initial_preconditioner-Union{Tuple{H}, Tuple{T}, Tuple{Dim}} where {Dim, T, H<:(HyperPowerPreconditioner{Dim, T, A, B} where {A<:LinearOperatorApproximation{Dim, T}, B<:Preconditioner{Dim, T}})}","page":"Home","title":"Taiga.hyperpower_initial_preconditioner","text":"hyperpower_initial_preconditioner(P::H)\n\nReturns the initial preconditioner that was used in the construction of P, e.g. FastDiagonalization.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.inner_solver_convergence-Tuple{S} where S<:Union{InnerCG, InnerPCG}","page":"Home","title":"Taiga.inner_solver_convergence","text":"inner_solver_convergence(P::S) where {S<:Union{InnerCG, InnerPCG}}\n\nReturns a vector booleans indicating convergence in last applications of InnerPCG preconditioner.\n\nSee reset_inner_solver_history! to reset history.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.inner_solver_niters-Tuple{S} where S<:Union{InnerCG, InnerPCG}","page":"Home","title":"Taiga.inner_solver_niters","text":"inner_solver_niter(P::S) where {S<:Union{InnerCG, InnerPCG}}\n\nReturns a vector with numbers of iterations in last applications of InnerCG and InnerPCG preconditioner.\n\nSee reset_inner_solver_history! to reset history.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.inner_solver_residuals-Tuple{S} where S<:Union{InnerCG, InnerPCG}","page":"Home","title":"Taiga.inner_solver_residuals","text":"inner_solver_residuals(P::S) where {S<:Union{InnerCG, InnerPCG}}\n\nReturns a vector with residuals in last applications of InnerPCG preconditioner. See reset_inner_solver_history! to reset history.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.linear_operator","page":"Home","title":"Taiga.linear_operator","text":"linear_operator()\n\nReturns a linear operator for a model. Each model module implements this.\n\n\n\n\n\n","category":"function"},{"location":"#Taiga.linear_operator_approximation","page":"Home","title":"Taiga.linear_operator_approximation","text":"linear_operator_approximation()\n\nReturns a linear operator approximation for a model. Some model modules implements this. Linear operator approximations are cheap to apply and useful in the context of preconditioning.\n\n\n\n\n\n","category":"function"},{"location":"#Taiga.linsolve!","page":"Home","title":"Taiga.linsolve!","text":"linsolve!\n\nLinear solvers implement this method. Typically, the syntax is linsolve!(solver, rhs; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"#Taiga.linsolve!-Union{Tuple{L}, Tuple{T}, Tuple{TaigaCG{T, L}, Vector{T}}} where {T, L}","page":"Home","title":"Taiga.linsolve!","text":"linsolve!(solver::TaigaCG{T, L}, b::Vector{T}; x0::Vector{T} = zeros(size(solver.A, 2)))\n\nSolve the linear system A x = b using TaigaCG.\n\nArguments:\n\nsolver: solver context\nb: rhs vector\nx0: initial guess\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.linsolve!-Union{Tuple{L}, Tuple{T}, Tuple{TaigaIPCG{T, L}, Vector{T}}} where {T, L}","page":"Home","title":"Taiga.linsolve!","text":"linsolve!(solver::TaigaCG{T, L}, b::Vector{T}; x0::Vector{T} = zeros(size(solver.A, 2)))\n\nSolve the linear system A x = b using TaigaIPCG.\n\nArguments:\n\nsolver: solver context\nb: rhs vector\nx0: initial guess\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.linsolve!-Union{Tuple{L}, Tuple{T}, Tuple{TaigaPCG{T, L}, Vector{T}}} where {T, L}","page":"Home","title":"Taiga.linsolve!","text":"linsolve!(solver::TaigaPCG{T, L}, b::Vector{T}; x0::Vector{T} = zeros(size(solver.A, 2)))\n\nSolve the linear system A x = b using TaigaPCG.\n\nArguments:\n\nsolver: solver context\nb: rhs vector\nx0: initial guess\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.reset!-Tuple{KroneckerFactory}","page":"Home","title":"Taiga.reset!","text":"reset!(f::KroneckerFactory)\n\nReset KroneckerProductAggregate collection in KroneckerFactory.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.reset_inner_solver_history!-Tuple{S} where S<:Union{InnerCG, InnerPCG}","page":"Home","title":"Taiga.reset_inner_solver_history!","text":"reset_inner_solver_niter_history!(P::S) where {S<:Union{InnerCG, InnerPCG}}\n\nReset history in InnerCG and InnerPCG preconditioner.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.system_matrix_integrand-Union{Tuple{T}, Tuple{UnivariateSplines.SplineSpace{T}, UnivariateSplines.SplineSpace{T}}, Tuple{UnivariateSplines.SplineSpace{T}, UnivariateSplines.SplineSpace{T}, Int64}, Tuple{UnivariateSplines.SplineSpace{T}, UnivariateSplines.SplineSpace{T}, Int64, Int64}} where T<:Real","page":"Home","title":"Taiga.system_matrix_integrand","text":"system_matrix_integrand(S::TargetSpace{T}, V::TestSpace{T}, k::Int = 1, l::Int = 1; x::T)\n\nEvaluates to the integrand of a system matrix ∫ s(ξ)v(ξ) dΩ for ξ = x where s ∈ S and v ∈ V.\n\nThis is useful i.e. in the definition of boundary integrals on Cartesian grids.\n\nArguments:\n\nS: a UnivariateSplines.SplineSpace as target space\nV: a UnivariateSplines.SplineSpace as test space\nk: derivative order on target space\nl: derivative order on test space\nx: evaluation point\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.update_linear_solver_statistics!-Union{Tuple{S}, Tuple{S, Any}} where S<:LinearSolver","page":"Home","title":"Taiga.update_linear_solver_statistics!","text":"update_linear_solver_statistics!(solver::S)\n\nFor η = √rᵀr and η₀ =  √r₀ᵀr₀ and check η < atol, η₀ < rtol and if number of iterations is equal to itmax. Sets solver.stats.converged and solver.stats.status accordingly.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_bezier_cell_degree-Union{Tuple{BezierExtractionContext{Dim, T}}, Tuple{T}, Tuple{Dim}} where {Dim, T}","page":"Home","title":"Taiga.vtk_bezier_cell_degree","text":"vtk_bezier_cell_degree(S::BezierExtractionContext{Dim, T}) where {Dim,T<:SplineSpace}\n\nComputes univariate degrees for a Bezier cell in a BezierExtractionContext.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_bezier_cell_degree-Union{Tuple{CartesianProducts.TensorProduct{Dim, T}}, Tuple{T}, Tuple{Dim}} where {Dim, T<:UnivariateSplines.SplineSpace}","page":"Home","title":"Taiga.vtk_bezier_cell_degree","text":"vtk_bezier_cell_degree(S::TensorProduct{Dim, T}) where {Dim,T<:SplineSpace}\n\nComputes a tuple of univariate degrees for a Bezier cell extracted from a tensor product spline space.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_bezier_cells-Tuple{BezierExtractionContext}","page":"Home","title":"Taiga.vtk_bezier_cells","text":"vtk_bezier_cells(B::VTKBezierExtractionContext)\n\nCollects all Bezier cells in B.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_bezier_degrees-Tuple{BezierExtractionContext}","page":"Home","title":"Taiga.vtk_bezier_degrees","text":"vtk_bezier_degrees(B::VTKBezierExtraction)\n\nReturns an immutable sparse array container of type VTKHigherOrderDegrees with cell degrees.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_cell_connectivity-Union{Tuple{BezierExtractionContext{Dim, T}}, Tuple{T}, Tuple{Dim}} where {Dim, T}","page":"Home","title":"Taiga.vtk_cell_connectivity","text":"vtk_cell_connectivity(B::BezierExtractionContext{Dim, T})\n\nReturns cell connectivity for a BezierExtractionContext.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_cell_point_indices-Union{Tuple{Tuple{Vararg{Int64, Dim}}}, Tuple{Dim}} where Dim","page":"Home","title":"Taiga.vtk_cell_point_indices","text":"vtk_cell_point_indices(order::NTuple{Dim, Int}) where {Dim}\n\nComputes point indices of a reference VTK Bezier cell with points indexed using Cartesian indices.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_cell_type-Tuple{BezierExtractionContext{1}}","page":"Home","title":"Taiga.vtk_cell_type","text":"vtk_cell_type(::VTKBezierExtraction{Dim}) where {Dim}\n\nReturns a Bezier cell type based on Dim.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_control_net_cells-Tuple{Vector{Tuple{Int64, Int64}}}","page":"Home","title":"Taiga.vtk_control_net_cells","text":"vtk_control_net_cells(connectivity::Vector{Tuple{Int, Int}})\n\nReturns a vector of VTKCellTypes.VTK_LINE cells given a vector of point connectivities.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_control_net_connectivity-Union{Tuple{AbstractMappings.GeometricMapping{Dim}}, Tuple{Dim}} where Dim","page":"Home","title":"Taiga.vtk_control_net_connectivity","text":"vtk_control_net_connectivity(mapping::GeometricMapping{Dim})\n\nGenerates a list of connectivity tuples for all edges of a control net based on the size of the control points grid in mapping.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_control_net_points-Union{Tuple{AbstractMappings.GeometricMapping{Dim, Codim}}, Tuple{Codim}, Tuple{Dim}} where {Dim, Codim}","page":"Home","title":"Taiga.vtk_control_net_points","text":"vtk_control_net_points(mapping::GeometricMapping{Dim, Codim})\n\nReturns vectorized NURBS coefficients (for WriteVTK purposes).\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_control_net_weights-Tuple{AbstractMappings.GeometricMapping}","page":"Home","title":"Taiga.vtk_control_net_weights","text":"vtk_control_net_weights(mapping::GeometricMapping)\n\nReturns vectorized NURBS weights (for WriteVTK purposes).\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_extract_bezier_points-Union{Tuple{Codim}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, AbstractMappings.Field{Dim, Codim}}} where {Dim, Codim}","page":"Home","title":"Taiga.vtk_extract_bezier_points","text":"vtk_extract_bezier_points(B::BezierExtractionContext{Dim}, F::Field{Dim, Codim})\n\nReturns Bezier points of a Bspline field.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_extract_bezier_points-Union{Tuple{Codim}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, AbstractMappings.GeometricMapping{Dim, Codim}}} where {Dim, Codim}","page":"Home","title":"Taiga.vtk_extract_bezier_points","text":"vtk_extract_bezier_points(B::BezierExtractionContext{Dim}, F::GeometricMapping{Dim, Codim}; bezier_weights = nothing, vectorize = true)\n\nReturns Bezier weights from a NURBS geometric mapping.\n\nIf vectorize is true the result is a tuple of vector views to the points.\n\nPrecomputed Bezier weights can be passed in bezier_weights explicitly. If not provided, these will be computed automatically.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_extract_bezier_points-Union{Tuple{M}, Tuple{T2}, Tuple{T1}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, M}} where {Dim, T1, T2, M<:IgaBase.AbstractMapping{Dim, T1, T2}}","page":"Home","title":"Taiga.vtk_extract_bezier_points","text":"vtk_extract_bezier_points(B::BezierExtractionContext{Dim}, F::M) where {Dim,Codim,M<:AbstractMapping}\n\nReturns Bezier points of Galerkin projection of an abstract mapping.\n\nConsider this a fallback routine: it is used only if the mapping F is not a B-spline or NURBS map. \n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_extract_bezier_points-Union{Tuple{T}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim, T}, Array{T, Dim}, Array{T, Dim}, Array{T, Dim}}} where {Dim, T}","page":"Home","title":"Taiga.vtk_extract_bezier_points","text":"vtk_extract_bezier_points(B::BezierExtractionContext{Dim, T}, bezier_weights::Array{T, Dim}, spline_weights::Array{T, Dim}, spline_coeffs::Array{T, Dim})\n\nReturns Bezier points from NURBS control points.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_extract_bezier_points-Union{Tuple{T}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim, T}, Array{T, Dim}}} where {Dim, T}","page":"Home","title":"Taiga.vtk_extract_bezier_points","text":"vtk_extract_bezier_points(B::BezierExtractionContext{Dim, T}, spline_coeffs::Array{T, Dim})\n\nReturns Bezier points from Bspline control points (i.e. without rational weighting).\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_extract_bezier_weights-Union{Tuple{Codim}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim}, AbstractMappings.GeometricMapping{Dim, Codim}}} where {Dim, Codim}","page":"Home","title":"Taiga.vtk_extract_bezier_weights","text":"vtk_extract_bezier_weights(B::BezierExtractionContext{Dim}, F::GeometricMapping{Dim, Codim})\n\nReturns Bezier weights from a NURBS geometric mapping.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_extract_bezier_weights-Union{Tuple{T}, Tuple{Dim}, Tuple{BezierExtractionContext{Dim, T}, Array{T, Dim}}} where {Dim, T}","page":"Home","title":"Taiga.vtk_extract_bezier_weights","text":"vtk_extract_bezier_weights(B::BezierExtractionContext{Dim, T}, spline_weights::Array{T, Dim})\n\nReturns Bezier weights from NURBS weights.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_map_linear_indices-Union{Tuple{N}, Tuple{AbstractArray, Tuple{Vararg{Int64, N}}}} where N","page":"Home","title":"Taiga.vtk_map_linear_indices","text":"vtk_map_linear_indices(lind::AbstractArray, connectivity::NTuple{N, Int}) where {N}\n\nMaps linear indices of a Bezier cell index by Cartesian indices based on the connectivity of a reference VTK Bezier cell.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_num_cell_vertices-Tuple{BezierExtractionContext}","page":"Home","title":"Taiga.vtk_num_cell_vertices","text":"vtk_num_cell_vertices(B::BezierExtractionContext)\n\nReturns number of vertices.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_num_cells-Tuple{BezierExtractionContext}","page":"Home","title":"Taiga.vtk_num_cells","text":"vtk_num_cells(B::BezierExtractionContext)\n\nReturns number of Bezier cells.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_point_index_from_ijk-Tuple{CartesianIndex{1}, Tuple{Int64}}","page":"Home","title":"Taiga.vtk_point_index_from_ijk","text":"vtk_point_index_from_ijk(inds::CartesianIndex{1}, order::NTuple{2, Int})\n\nComputes VTK point index based on Cartesian index of a cell point.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_point_index_from_ijk-Tuple{CartesianIndex{2}, Tuple{Int64, Int64}}","page":"Home","title":"Taiga.vtk_point_index_from_ijk","text":"vtk_point_index_from_ijk(inds::CartesianIndex{2}, order::NTuple{2, Int})\n\nComputes VTK point index based on Cartesian index of a cell point.\n\nAdapted from VTK's vtkHigherOrderHexahedron::PointIndexFromIJK().\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_point_index_from_ijk-Tuple{CartesianIndex{3}, Tuple{Int64, Int64, Int64}}","page":"Home","title":"Taiga.vtk_point_index_from_ijk","text":"vtk_point_index_from_ijk(inds::CartesianIndex{3}, order::NTuple{3, Int})\n\nComputes VTK point index based on Cartesian index of a cell point.\n\nAdapted from VTK's vtkHigherOrderHexahedron::PointIndexFromIJK().\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_reference_cell_connectivity-Union{Tuple{Array{Int64, Dim}}, Tuple{Dim}} where Dim","page":"Home","title":"Taiga.vtk_reference_cell_connectivity","text":"vtk_reference_cell_connectivity(point_indices::Array{Int, Dim}) where {Dim}\n\nComputes cell connectivity of a reference VTK Bezier cell with points indexed using Cartesian indices.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_save_bezier-Union{Tuple{T}, Tuple{String, AbstractMappings.GeometricMapping}} where T<:IgaBase.AbstractMapping","page":"Home","title":"Taiga.vtk_save_bezier","text":"vtk_save_bezier(filepath::String, mapping::GeometricMapping; fields::Union{Dict{String,T},Nothing}=nothing) where {T<:AbstractMapping}\n\nPerform Bezier extraction and save a VTK file with the result.\n\nmapping is a expected to be a NURBS. The optional dictionary fields may contain fields defined by Bsplines.\n\nArguments:\n\nfilepath: output file path without extension\nmapping: geometric mapping\nfields: a dictionary of strings\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.vtk_save_control_net-Tuple{String, AbstractMappings.GeometricMapping}","page":"Home","title":"Taiga.vtk_save_control_net","text":"vtk_save_control_net(filepath::String, mapping::GeometricMapping)\n\nSave a VTK file with the control net of a NURBS geometric mapping. The VTK file will contain a dataset with the NURBS weights per control point.\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.weighted_system_matrix","page":"Home","title":"Taiga.weighted_system_matrix","text":"weighted_system_matrix(S::TargetSpace, V::TestSpace, data::Bspline, k::Int = 1, l::Int = 1)\n\nReturns a univariate system matrix as in UnivariateSplines.system_matrix but applies a spline weighting function to the test functions.\n\nArguments:\n\nS: trial space\nV: test space\ndata: univariate spline weighting function\nk: derivative order on trial functions\nl: derivarive order on test functions\n\n\n\n\n\n","category":"function"},{"location":"#Taiga.weighted_system_matrix-2","page":"Home","title":"Taiga.weighted_system_matrix","text":"weighted_system_matrix(S::TargetSpace, V::TestSpace, data::AbstractVector, k::Int = 1, l::Int = 1)\n\nReturns a univariate system matrix as in UnivariateSplines.system_matrix but applies weighting to the test function defined by a data vector.\n\nArguments:\n\nS: trial space\nV: test space\ndata: vector with weights\nk: derivative order on trial functions\nl: derivarive order on test functions\n\n\n\n\n\n","category":"function"},{"location":"#Taiga.ι-Tuple{Int64, Int64}","page":"Home","title":"Taiga.ι","text":"ι(k::Int, l::Int; val::NTuple{2,Int}=(1,1), dim::Int=3)\n\nBrief magic function that returns a tuple of integers with length dim where k-th integer is equal to val[1], l-th integer is equal to val[2] and the rest is zero. If k and l coincide, the values are summed up.\n\nThis is in particular useful to define tuples for test and trial function derivatives in sum factorization loops, e.g.\n\nExample:\n\njulia> ∇²u(k, l) = ι(k, l, dim = 2);\n\njulia> ∇²u(1, 1)\n(2, 0)\n\njulia> ∇²u(1, 2)\n(1, 1)\n\njulia> ∇²u(2, 1)\n(1, 1)\n\njulia> ∇²u(2, 2)\n(0, 2)\n\n\n\n\n\n","category":"method"},{"location":"#Taiga.ι-Tuple{Int64}","page":"Home","title":"Taiga.ι","text":"ι(k::Int; val::Int=1, dim::Int=3)\n\nBrief magic function that returns a tuple of integers with length dim where k-th integer is equal to val and the rest is zero.\n\nThis is in particular useful to define tuples for test and trial function derivatives in sum factorization loops, e.g.\n\nExample:\n\njulia> u = ι(0, dim = 2);\n\njulia> ∇u(k) = ι(k, dim = 2);\n\njulia> u\n(0, 0)\n\njulia> ∇u(1)\n(1, 0)\n\njulia> ∇u(2)\n(0, 1)\n\njulia> ∇²ₖₖu(k) = ι(k, val=2, dim = 2);\n\njulia> ∇²ₖₖu(1)\n(2, 0)\n\njulia> ∇²ₖₖu(2)\n(0, 2)\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#LinearElasticity","page":"Linear elasticity","title":"LinearElasticity","text":"This module implements a Galerkin discretization of linear elastic problems.\n\n(Image: Hole in a three-dimensional plate)\n\n./examples/linearelasticity/hole_in_a_plate_3d.jl","category":"section"},{"location":"linearelasticity/#Index","page":"Linear elasticity","title":"Index","text":"","category":"section"},{"location":"linearelasticity/#Taiga.FastDiagonalization-Union{Tuple{Taiga.LinearElasticity.Model{Dim, T, M, V, W, U} where {M<:(AbstractMappings.GeometricMapping{Dim}), V<:SpecialSpaces.VectorSplineSpace{Dim, Dim, T}, W<:(AbstractMappings.Field{Dim}), U<:(Taiga.LinearElasticity.Material{Dim})}}, Tuple{T}, Tuple{Dim}} where {Dim, T}","page":"Linear elasticity","title":"Taiga.FastDiagonalization","text":"Taiga.FastDiagonalization(model::Model{Dim, T}; method::Type{<:DataApproximationMethod} = Wachspress, kwargs)\n\nComputes a block diagonal fast diagonalization preconditioner for Model.\n\nArguments:\n\nmodel: Model model definition\nmethod: method for data approximation\nkwargs: optional keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.BMatrix","page":"Linear elasticity","title":"Taiga.LinearElasticity.BMatrix","text":"BMatrix{Dim, F}\n\nStruct holding B-matrices (strain-displacement matrices). Supports linear indexing.\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.BenchmarkSolution","page":"Linear elasticity","title":"Taiga.LinearElasticity.BenchmarkSolution","text":"BenchmarkSolution\n\nStruct holding displacement and stress mappings for benchmark problems.\n\nFields:\n\ndisplacement::Function: displacement vector as a function of physical coordinates\nstress::Function: stress tensor as a function of physical coordinates\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.CauchyStress","page":"Linear elasticity","title":"Taiga.LinearElasticity.CauchyStress","text":"CauchyStress{Dim, T <: Strain{Dim}} <: AbstractMapping{Dim,Dim,Dim}\n\nMapping for evaluation of Cauchy stress:\n\nboldsymbol sigma = mathbf C  boldsymbol varepsilon.\n\nFields:\n\nstrain::T: Strain\nmaterial::Material{Dim}: Material\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.Isotropic","page":"Linear elasticity","title":"Taiga.LinearElasticity.Isotropic","text":"Isotropic <: Material{3,6}\n\nIsotropic material.\n\nFields:\n\nE::Function: Young's modulus\nν::Function: Poisson's ratio\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.LinearOperator","page":"Linear elasticity","title":"Taiga.LinearElasticity.LinearOperator","text":"LinearOperator{Dim, T} <: Taiga.LinearOperator{Dim,T}\n\nLinear operator for linear elastic models.\n\nFields:\n\nC::SparseMatrixCSC{T}: sparse extraction operator\nK::SparseMatrixCSC{T}: sparse stiffness matrix without constraints\nL::SparseMatrixCSC{T}: sparse stiffness matrix including constraints\nb::Vector{T}: load vector\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.Material","page":"Linear elasticity","title":"Taiga.LinearElasticity.Material","text":"abstract type Material{Dim,S} <: AbstractMapping{Dim,S,S} end\n\nAll linear elastic materials derive from this. Materials are mappings in Dim × S × S.\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.Model","page":"Linear elasticity","title":"Taiga.LinearElasticity.Model","text":"Model{Dim, T, M <: GeometricMapping{Dim}, V <: VectorSplineSpace{Dim, T}, W <: Field{Dim}, U <: Material{Dim}} <: Taiga.Model{Dim,T}\n\nLinear elastic model.\n\nFields:\n\nF::M: geometric mapping\nS::V: test and trial space\nΔ::Partition{Dim, T}: partition\nuʰ::W: solution field\nūʰ::W: field compatible with boundary conditions\nt::Function: traction\nmaterial::U: material\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.Orthotropic","page":"Linear elasticity","title":"Taiga.LinearElasticity.Orthotropic","text":"Orthotropic <: Material{3,6}\n\nOrthotropic material.\n\nFields:\n\nE₁::Function: Young's modulus\nE₂::Function: Young's modulus\nE₃::Function: Young's modulus\nν₂₃::Function: Poisson's ratio\nν₃₂::Function: Poisson's ratio\nν₁₃::Function: Poisson's ratio\nν₃₁::Function: Poisson's ratio\nν₁₂::Function: Poisson's ratio\nν₂₁::Function: Poisson's ratio\nG₂₃::Function: Shear modulus\nG₁₃::Function: Shear modulus\nG₁₂::Function: Shear modulus\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.PlaneStrain","page":"Linear elasticity","title":"Taiga.LinearElasticity.PlaneStrain","text":"PlaneStrain <: Material{2,3}\n\nPlane strain material.\n\nFields:\n\nE::Function: Young's modulus\nν::Function: Poisson's ratio\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.PlaneStress","page":"Linear elasticity","title":"Taiga.LinearElasticity.PlaneStress","text":"PlaneStress <: Material{2,3}\n\nPlane stress material.\n\nFields:\n\nE::Function: Young's modulus\nν::Function: Poisson's ratio\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.PullbackBilinearForm","page":"Linear elasticity","title":"Taiga.LinearElasticity.PullbackBilinearForm","text":"PullbackBilinearForm{Dim, T1 <: GeometricMapping{Dim}, T2 <: Material{Dim}}\n\nPullback of the bilinear form.\n\nFields:\n\nmapping::T1: geometric mapping\nmaterial::T2: material\nB::BMatrix{Dim}: B-matrices.\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.PullbackBoundaryLinearForm","page":"Linear elasticity","title":"Taiga.LinearElasticity.PullbackBoundaryLinearForm","text":"PullbackBoundaryLinearForm{Dim, S}\n\nPullback of the linear form on the boundary. The parameter 1 ≤ S ≤ 2Dim denotes the coressponding boundary face.\n\nFields:\n\nmapping::GeometricMapping{Dim}: geometric mapping\ntraction::Function: traction tensor as a function of physical coordinates\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.Strain","page":"Linear elasticity","title":"Taiga.LinearElasticity.Strain","text":"Strain{Dim, T1 <: GeometricMapping{Dim}, T2 <: Field{Dim, Dim}} <: AbstractMapping{Dim,Dim,Dim}\n\nMapping for evaluation of strain:\n\nboldsymbol varepsilon = frac 1 2 (nabla mathbf u + nabla mathbf u^T).\n\nFields:\n\nmapping::T1: geometric mapping\ndisplacement::T2: displacement field\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#Taiga.LinearElasticity.VonMisesStress","page":"Linear elasticity","title":"Taiga.LinearElasticity.VonMisesStress","text":"VonMisesStress{Dim, T <: CauchyStress{Dim}}\n\nMapping for evaluation of von Mises stress.\n\nbeginaligned\nmathbfs = boldsymbolsigma - frac12 mathrmtr(boldsymbolsigma) mathbfI \nJ_2 = mathbfs  mathbfs) \nboldsymbolsigma_mathrmvM = sqrt3 J_2\nendaligned\n\nFields:\n\nstress::T: CauchyStress\n\n\n\n\n\n","category":"type"},{"location":"linearelasticity/#SparseArrays.sparse-Tuple{Taiga.LinearElasticity.LinearOperator}","page":"Linear elasticity","title":"SparseArrays.sparse","text":"SparseArrays.sparse(L::LinearOperator)\n\nGet sparse linear operator.\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.assemble_matrix-Union{Tuple{Dim}, Tuple{IgaFormation.ElementAccessor{Dim}, CartesianProducts.CartesianProduct{Dim, Tuple{Vararg{T, Dim}}, Tuple{Vararg{S, Dim}}} where {T, S<:SortedSequences.IncreasingSequence{T}}, Taiga.LinearElasticity.PullbackBilinearForm{Dim, T1, T2} where {T1<:(AbstractMappings.GeometricMapping{Dim}), T2<:(Taiga.LinearElasticity.Material{Dim})}}} where Dim","page":"Linear elasticity","title":"Taiga.LinearElasticity.assemble_matrix","text":"assemble_matrix(acc::ElementAccessor{Dim}, partition::Partition{Dim}, pullback::PullbackBilinearForm{Dim}; show_progress::Bool = true)\n\nAssemble stiffness matrix. \n\nArguments:\n\nacc: element accessor\npartition: partition\npullback: pullback of bilinear form\nshow_progress: boolean flag for formation progress bar\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.assemble_vector-Union{Tuple{N}, Tuple{Dim}, Tuple{IgaFormation.ElementAccessor{Dim}, CartesianProducts.CartesianProduct{Dim, Tuple{Vararg{T, Dim}}, Tuple{Vararg{S, Dim}}} where {T, S<:SortedSequences.IncreasingSequence{T}}, Tuple{Vararg{Taiga.LinearElasticity.PullbackBoundaryLinearForm, N}}}} where {Dim, N}","page":"Linear elasticity","title":"Taiga.LinearElasticity.assemble_vector","text":"assemble_vector(acc::ElementAccessor{Dim}, partition::Partition{Dim}, pullbacks::NTuple{N, PullbackBoundaryLinearForm})\n\nAssemble forcing vector.\n\nArguments:\n\nacc: element accessor\npartition: partition\npullbacks: tuple of pullbacks of the linear form on each of the boundaries\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.benchmark_hole_in_plate_2d-Tuple{}","page":"Linear elasticity","title":"Taiga.LinearElasticity.benchmark_hole_in_plate_2d","text":"benchmark_hole_in_plate_2d(; E, ν)\n\nHole in a plate benchmark in two dimensions.\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.benchmark_hole_in_plate_3d-Tuple{}","page":"Linear elasticity","title":"Taiga.LinearElasticity.benchmark_hole_in_plate_3d","text":"benchmark_hole_in_plate_3d(; E, ν)\n\nHole in a plate benchmark in three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.benchmark_spherical_cavity-Tuple{}","page":"Linear elasticity","title":"Taiga.LinearElasticity.benchmark_spherical_cavity","text":"benchmark_spherical_cavity(; E, ν)\n\nSpherical cavity benchmark in three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.material_matrix-Tuple{Type{Taiga.LinearElasticity.Isotropic}, Any, Any}","page":"Linear elasticity","title":"Taiga.LinearElasticity.material_matrix","text":"material_matrix(::Type{Isotropic}, E, ν)\n\nReturns the elasticity tensor in Voigt notation.\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.material_matrix-Tuple{Type{Taiga.LinearElasticity.Orthotropic}, Vararg{Any, 12}}","page":"Linear elasticity","title":"Taiga.LinearElasticity.material_matrix","text":"material_matrix(::Type{Orthotropic}, E₁, E₂, E₃, ν₂₃, ν₃₂, ν₁₃, ν₃₁, ν₁₂, ν₂₁, G₂₃, G₁₃, G₁₂)\n\nReturns the elasticity tensor in Voigt notation.\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.material_matrix-Tuple{Type{Taiga.LinearElasticity.PlaneStrain}, Any, Any}","page":"Linear elasticity","title":"Taiga.LinearElasticity.material_matrix","text":"material_matrix(::Type{PlaneStrain}, E, ν)\n\nReturns the elasticity tensor in Voigt notation.\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.material_matrix-Tuple{Type{Taiga.LinearElasticity.PlaneStress}, Any, Any}","page":"Linear elasticity","title":"Taiga.LinearElasticity.material_matrix","text":"material_matrix(::Type{PlaneStress}, E, ν)\n\nReturns the elasticity tensor in Voigt notation.\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.LinearElasticity.σ_voigt","page":"Linear elasticity","title":"Taiga.LinearElasticity.σ_voigt","text":"σ_voigt(A::SMatrix) -> SVector\nσ_voigt(v::SVector) -> SMatrix\n\nConvert between standard and Voigt notation for stress.\n\nσ_voigt(A::SMatrix{2,2}): Converts a 2×2 stress tensor to a 3-component Voigt vector.\nσ_voigt(A::SMatrix{3,3}): Converts a 3×3 stress tensor to a 6-component Voigt vector.\nσ_voigt(v::SVector{3}): Converts a 3-component Voigt stress vector to a 2×2 stress tensor.\nσ_voigt(v::SVector{6}): Converts a 6-component Voigt stress vector to a 3×3 stress tensor.\n\nShear components remain unchanged in Voigt notation.\n\n\n\n\n\n","category":"function"},{"location":"linearelasticity/#Taiga.LinearElasticity.ϵ_voigt","page":"Linear elasticity","title":"Taiga.LinearElasticity.ϵ_voigt","text":"ϵ_voigt(A::SMatrix) -> SVector\nϵ_voigt(v::SVector) -> SMatrix\n\nConvert between standard and Voigt notation for strain.\n\nϵ_voigt(A::SMatrix{2,2}): Converts a 2×2 strain tensor to a 3-component Voigt vector.\nϵ_voigt(A::SMatrix{3,3}): Converts a 3×3 strain tensor to a 6-component Voigt vector.\nϵ_voigt(v::SVector{3}): Converts a 3-component Voigt strain vector to a 2×2 strain tensor.\nϵ_voigt(v::SVector{6}): Converts a 6-component Voigt strain vector to a 3×3 strain tensor.\n\nShear components are multiplied by 2 when converting to Voigt notation.\n\n\n\n\n\n","category":"function"},{"location":"linearelasticity/#Taiga.apply_particular_solution-Union{Tuple{V}, Tuple{Dim}, Tuple{Taiga.LinearElasticity.LinearOperator{Dim}, Taiga.LinearElasticity.Model{Dim, T, M, V, W, U} where {T, M<:(AbstractMappings.GeometricMapping{Dim}), V<:SpecialSpaces.VectorSplineSpace{Dim, Dim, T}, W<:(AbstractMappings.Field{Dim}), U<:(Taiga.LinearElasticity.Material{Dim})}, V}} where {Dim, V<:(AbstractVector)}","page":"Linear elasticity","title":"Taiga.apply_particular_solution","text":"Taiga.apply_particular_solution(L::LinearOperator, model::Model, x₀::V)\n\nReturn particular solution.\n\nArguments:\n\nL: linear operator\nmodel: model\nx₀: homogeneous solution\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.forcing!-Union{Tuple{Dim}, Tuple{AbstractVector, Taiga.LinearElasticity.LinearOperator{Dim}, Taiga.LinearElasticity.Model{Dim, T, M, V, W, U} where {T, M<:(AbstractMappings.GeometricMapping{Dim}), V<:SpecialSpaces.VectorSplineSpace{Dim, Dim, T}, W<:(AbstractMappings.Field{Dim}), U<:(Taiga.LinearElasticity.Material{Dim})}}} where Dim","page":"Linear elasticity","title":"Taiga.forcing!","text":"Taiga.forcing!(b::AbstractVector, L::LinearOperator, model::Model)\n\nUpdate forcing vector.\n\nArguments:\n\nb: cache vector\nL: linear operator\nmodel: model\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.forcing-Tuple{Taiga.LinearElasticity.LinearOperator, Taiga.LinearElasticity.Model}","page":"Linear elasticity","title":"Taiga.forcing","text":"Taiga.forcing(L::LinearOperator, model::Model)\n\nReturn forcing vector.\n\n\n\n\n\n","category":"method"},{"location":"linearelasticity/#Taiga.linear_operator-Tuple{Taiga.LinearElasticity.Model}","page":"Linear elasticity","title":"Taiga.linear_operator","text":"Taiga.linear_operator(model::Model; show_progress::Bool = true)\n\nConstruct linear operator.\n\n\n\n\n\n","category":"method"}]
}
